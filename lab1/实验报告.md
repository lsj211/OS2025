练习一：





练习二：
我们先不运行，通过gdb调试查找到bootstacktop
(gdb) info address bootstacktop
```bash
Symbol "bootstacktop" is at 0x80203000 in a file compiled without debugging.
```
但此时，bootstacktop并未写到sp寄存器中
(gdb) info registers sp
`sp             0x0      0x0`

接着，我们来分析这个栈顶地址是怎么得到的
```bash
Symbols from "/home/op_user/projects/labcode/lab1/bin/kernel".
Remote target using gdb-specific protocol:
        `/home/op_user/projects/labcode/lab1/bin/kernel', file type elf64-littleriscv.
        Entry point: 0x80200000
        0x0000000080200000 - 0x00000000802004a2 is .text
        0x00000000802004a8 - 0x0000000080200718 is .rodata
        0x0000000080201000 - 0x0000000080203000 is .data
        0x0000000080203000 - 0x0000000080203008 is .sdata
```
我们可以发现，加载的入口位于`0x80200000`,然后存放.text(代码指令)以及.rodata（字符串，常量）
对于.data,我们观察entry.S中的代码
```
.section .data
    # .align 2^12
    .align PGSHIFT
    .global bootstack
bootstack:
    .space KSTACKSIZE
    .global bootstacktop
```
bootstack包含在data中，并且bootsatck占KSTACKSIZE（由mmu.h中的数据可算出所占大小0x2000），
由于data中未包含其他变量，bootstack从0x80201000开始到0x80203000结束，
bootsatcktop为0x80203000，与我们之前得到的数据相符

接下来，我们运行源程序，观察这些代码的作用。
(gdb) info address kern_entry
Symbol "kern_entry" is at 0x80200000 in a file compiled without debugging.
可以得知，从0x80200000处开始执行我的代码。


查看kern_entry的汇编代码
```bash
Dump of assembler code for function kern_entry:
   0x0000000080200000 <+0>:     auipc   sp,0x3
   0x0000000080200004 <+4>:     mv      sp,sp
   0x0000000080200008 <+8>:     j       0x8020000a <kern_init>
```
其中，这两条指令对应`la sp, bootstacktop`:
   0x0000000080200000 <+0>:     auipc   sp,0x3
   0x0000000080200004 <+4>:     mv      sp,sp