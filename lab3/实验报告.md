# 操作系统lab3实验报告

## 一、练习1：完善中断处理

### 1.1 实验目的
实现时钟中断处理逻辑，使操作系统每累计100次时钟中断后打印"100 ticks"，累计打印10行后自动关机。

### 1.2 实现思路
1. 在时钟中断处理函数中，首先设置下次时钟中断触发时间，保证时钟中断能够持续产生
2. 定义静态计数器`ticks`用于累计时钟中断次数
3. 定义静态计数器`num`用于累计打印行数
4. 当日钟中断次数达到100时，打印"100 ticks"，重置`ticks`计数器并递增`num`计数器
5. 当`num`计数器达到10时，调用`sbi_shutdown()`函数实现关机

### 1.3 核心代码实现
在`trap.c`文件的中断处理函数中，针对`IRQ_S_TIMER`（监督者模式定时器中断）的处理逻辑如下：
```c
case IRQ_S_TIMER:
    // 设置下次时钟中断
    clock_set_next_event();
    // 定义静态计数器，用于累计中断次数和打印次数
    static int ticks = 0;
    static int num = 0;
    // 每次中断，ticks计数器加1
    ticks++;
    // 累计100次中断时打印信息
    if (ticks == 100){
        cprintf("%d ticks\n", ticks);
        num++;  // 打印次数加1
        ticks = 0;  // 重置ticks计数器
    }
    // 累计打印10行后关机
    if (num == 10){
        sbi_shutdown();
    }   
    break;
```

### 1.4 定时器中断处理流程
1. 硬件产生定时器中断信号，CPU进入中断处理流程
2. 系统跳转到中断向量表，找到对应的定时器中断处理入口
3. 保存当前执行上下文到`trapframe`结构中
4. 进入中断处理函数`interrupt_handler`，通过`cause`值判断为定时器中断（`IRQ_S_TIMER`）
5. 执行时钟中断处理逻辑：
    - 调用`clock_set_next_event()`设置下次中断时间
    - 递增`ticks`计数器
    - 检查`ticks`是否达到100，若达到则打印信息并重置计数器
    - 检查打印次数是否达到10，若达到则调用关机函数
6. 恢复中断前的执行上下文，继续执行原来的程序

### 1.5 实验结果
程序运行后，约每1秒在屏幕上打印一行"100 ticks"，累计打印10行后，系统自动关机，符合实验预期。

## 二、Challenge1：中断异常处理流程与 SAVE_ALL 分析

本节基于 lab3 的实现（`kern/trap/trapentry.S`, `kern/trap/trap.c`, `kern/trap/trap.h`）对 ucore 中处理中断/异常的流程进行描述，并回答题目中的三个问题。

### 2.1 中断/异常从产生到处理的整体流程

1. 硬件或环境产生中断/异常（例如外设中断、定时器中断、非法指令等）。
2. CPU 保存必要的控制状态并跳转到在 `stvec` 中注册的异常入口 `__alltraps`（由 `idt_init()` 在 `trap.c` 中通过 `write_csr(stvec, &__alltraps)` 设置）。
3. `__alltraps`（见 `trapentry.S`）通过宏 `SAVE_ALL` 在内核栈上为当前上下文分配保存区并依次把通用寄存器和若干 CSR（如 `sstatus`、`sepc`、`stval`、`scause` 等）保存到栈上，形成一个 `struct trapframe` 对应的内存布局。
4. `__alltraps` 将当前栈指针（指向保存好的 trapframe）放到 `a0` 寄存器（通过 `move a0, sp`），随后调用 C 语言编写的 `trap(struct trapframe *tf)`（通过 `jal trap`）进入内核的高层处理逻辑。
5. `trap()` 根据 `tf->cause` 判断是中断还是异常，分发给 `interrupt_handler()` 或 `exception_handler()` 做具体处理。
6. 处理完成后 `trap()` 返回到汇编代码，`__trapret` 使用宏 `RESTORE_ALL` 从栈中恢复寄存器和 CSR，然后执行 `sret` 返回到发生异常/中断前的上下文继续执行。

该流程保证了在内核处理过程中，用户或被中断的进程上下文被完整保存并能在处理完毕后恢复。

### 2.2 为什么要执行 `move a0, sp`？

`move a0, sp` 的作用是把当前内核栈指针（sp）传递给 `trap()` 函数的第一个参数（在 RISC-V 调用约定中，第一个整型/指针参数放在寄存器 `a0`）。

更具体地：
- 在 `SAVE_ALL` 宏中，汇编把寄存器、sstatus、sepc、stval、scause 等按特定偏移保存到当前 `sp` 指向的栈帧内。保存完成后，`sp` 指向的是这个完整的 trapframe 的起始地址。
- C 函数 `trap(struct trapframe *tf)` 期望接收一个指向该 trapframe 的指针，便于在 C 中通过 `tf->...` 访问保存的寄存器与 CSR。通过 `move a0, sp`，汇编把该指针放入 `a0`，随后 `jal trap` 就能以正确的参数调用 `trap()`。

因此，`move a0, sp` 是连接低级汇编保存上下文与高级 C 处理逻辑的必要桥梁，使 C 代码可以直接访问保存在栈上的 `struct trapframe`。

### 2.3 SAVE_ALL 中寄存器保存在栈中的位置如何确定？

寄存器在栈中保存的位置由 `SAVE_ALL` 宏中的存储顺序与偏移决定，宏使用常量 `REGBYTES` 作为每个寄存器条目的字节宽度（通常为 8 字节或 4 字节，取决于架构），并用类似 `STORE xN, K*REGBYTES(sp)` 的指令把寄存器保存到 `sp` 的偏移处。

在本实现中，`SAVE_ALL` 做了以下关键操作（简化说明）：

- 首先执行 `csrw sscratch, sp`（将当前内核栈顶地址写入 `sscratch`），用于标识内核正在处理异常（并为递归异常提供检测手段）。
- 接着 `addi sp, sp, -36 * REGBYTES` 为保存区在栈上腾出空间（36 个寄存器/条目）。
- 然后按固定的索引顺序用 `STORE` 指令将 x0, x1, x3...x31 写入各自的偏移位置。例如 `STORE x1, 1*REGBYTES(sp)` 意味着寄存器 x1 的内容被保存到从 `sp` 起第 1 个寄存器槽的位置。
- 对若干 CSR（通过 `csrr` 读取）也按指定偏移（例如 `32*REGBYTES(sp)` 存 `sstatus`，`33*REGBYTES(sp)` 存 `sepc`，依次类推）保存。

该偏移和顺序在 `trap.h` 中的 `struct pushregs` 与 `struct trapframe` 的字段顺序上是一一对应的，因此在 C 代码中可以通过类型化的指针访问被存储的寄存器值。

拿 `struct pushregs` 的前几个字段为例：
- `zero` 对应栈偏移 `0*REGBYTES`
- `ra` 对应栈偏移 `1*REGBYTES`
- `sp` 对应栈偏移 `2*REGBYTES`
- `gp` 对应栈偏移 `3*REGBYTES`

（注意：汇编中保存顺序略有差别，例如 x2(sp) 在 RESTORE 阶段被标记为“最后恢复 sp”——这是为了避免在还原其它寄存器之前改变栈指针导致访问已释放的栈空间。）

总结：栈中保存位置由 `SAVE_ALL` 中的偏移常量与 `struct pushregs`/`struct trapframe` 的定义共同决定。

### 2.4 对于任何中断，__alltraps 中都需要保存所有寄存器吗？是否必要？

并非每一种中断都严格需要保存所有寄存器，但实现上 `__alltraps` 采用保存全部通用寄存器（以及若干关键 CSR）的策略，这是一个工程上的权衡，理由如下：

优点：
- 简单通用：对所有中断/异常统一使用相同的保存/恢复序列，避免为每种中断分别编写和维护不同的汇编序列，减少出错概率。
- 安全性高：即便中断处理函数会修改任意寄存器，也能保证原上下文完整恢复，适用于内核中可能调用任意 C 函数或库例程的场景。

缺点与优化点：
- 性能开销：保存/恢复所有寄存器比只保存必要寄存器更慢，特别是在高频率中断（如定时器）下会带来明显开销。
- 可选的精简策略：在性能敏感的实现中，可以按中断类型只保存必要寄存器（例如仅保存 caller-saved 寄存器或仅保存会被中断处理路径修改的寄存器），或者在汇编中使用延迟保存/按需保存等优化技术。

因此，是否“必须”保存所有寄存器取决于设计目标：如果优先考虑实现简单性和正确性，保存所有寄存器是合适的；如果追求高性能且能保证更复杂的上下文管理正确性，则可以采用更细粒度的保存策略以减少开销。

在 lab3 的实现中，选择保存所有寄存器以保证安全、可维护并且便于在 C 层统一访问 `struct trapframe`。

### 2.5 小结

- `__alltraps` 是低级异常入口，`SAVE_ALL` 在栈上构造 `struct trapframe`，`move a0, sp` 把该 trapframe 的地址传递给 C 函数 `trap()`。
- 寄存器保存位置由 `SAVE_ALL` 的偏移和 `struct pushregs/struct trapframe` 字段顺序决定。
- 保存所有寄存器不是硬性必须，但在该教学内核中为了简单性与安全性选择了保存全部寄存器；生产级系统可能会为性能而使用按需保存优化。



## 三、Challenge2：理解上下文切换机制

### 问题描述
在 `trapentry.S` 中出现如下汇编操作：
- `csrw sscratch, sp`
- `csrrw s0, sscratch, x0`

请解释这些指令实现了什么操作、目的是什么？
另外，`SAVE_ALL` 中保存了 CSR 如 `stval`、`scause` 等，但 `RESTORE_ALL` 中并没有逐一还原这些 CSR（只恢复了 `sstatus` 和 `sepc`），那把这些 CSR 存到栈上的意义何在？

### 说明
相关源码位置：
- `kern/trap/trapentry.S`：保存/恢复上下文和中断入口 `__alltraps` 的实现
- `kern/trap/trap.c`：高层 `trap()`、`interrupt_handler()`、`exception_handler()` 的实现
- `kern/trap/trap.h`：`struct pushregs` 与 `struct trapframe` 定义

关键片段（简化）来自 `trapentry.S`：
```asm
    .macro SAVE_ALL
    csrw sscratch, sp
    ...
    csrrw s0, sscratch, x0
    csrr s1, sstatus
    csrr s2, sepc
    csrr s3, stval
    csrr s4, scause
    STORE s0, 2*REGBYTES(sp)
    STORE s1, 32*REGBYTES(sp)
    STORE s2, 33*REGBYTES(sp)
    STORE s3, 34*REGBYTES(sp)
    STORE s4, 35*REGBYTES(sp)
    .endm
```

`RESTORE_ALL` 只恢复了 `sstatus` 和 `sepc`：
```asm
    LOAD s1, 32*REGBYTES(sp)
    LOAD s2, 33*REGBYTES(sp)

    csrw sstatus, s1
    csrw sepc, s2
    ...
```

### 指令语义与目的

1. csrw sscratch, sp
- 含义：把当前的栈指针 `sp` 写入 CSR 寄存器 `sscratch`（Supervisor Scratch Register）。
- 目的：
  - `sscratch` 在 RISC-V 的特权架构中是为异常/中断处理程序保留的临时 CSR，通常用于存放内核栈顶或指向当前 trapframe 的指针。
  - 在该实现中，写入 `sscratch` 起两个作用：
    1. 标记当前线程/内核正在处理异常（可用作递归异常检测或在异常发生时辨识上下文来源）。
    2. 为在异常处理流程中（或发生递归异常时）能够迅速访问到当前栈指针或 trapframe 地址提供一个固定寄存器位置（CSR），便于其它汇编/例外路径读取。

2. csrrw s0, sscratch, x0
- 含义：原子地读取 `sscratch` 的值到通用寄存器 `s0`，同时把 x0（0）写回 `sscratch`。`csrrw rd, csr, rs1` 执行：t = csr; csr = rs1; rd = t。
- 在这儿等于“把 sscratch 的旧值读到 s0，然后把 0 写入 sscratch”。
- 目的：
  - 读取旧的 `sscratch` 值并保存在 `s0`（随后被存到 trapframe 的相应槽），这可以记录异常发生之前 `sscratch` 的内容（通常用于判断是否发生了递归异常，或记录前一个上下文的栈指针）。
  - 将 `sscratch` 置为 0：在内核开始处理新异常时清零 `sscratch`，表明当前已经在内核异常处理路径中；如果在处理内核异常期间又发生异常（递归异常），异常向量可以检测到 `sscratch` 非 0（或原值），从而采取不同的处理策略或避免覆盖已存在的处理上下文。
  - 因此，`csrrw s0, sscratch, x0` 同时完成了“保存旧 sscratch 值（记录/回溯信息）”和“把 sscratch 清零（标识内核异常处理正在执行）”两项工作。

### 为什么 SAVE_ALL 要保存 `stval`, `scause` 等 CSR？
- 这些 CSR（`sstatus`、`sepc`、`stval`、`scause` 等）包含了异常/中断的关键信息：
  - `sstatus`：超级模式状态寄存器（含 SPP、SPIE、SPP 等控制位），与返回权限与中断使能状态相关。
  - `sepc`：异常发生时的程序计数（返回地址）。
  - `scause`：异常/中断原因编码（用来区分是哪类异常/中断）。
  - `stval`：与异常相关的附加信息（例如导致异常的地址，如页错误的 badvaddr）。
- 将它们保存到栈（trapframe）让 C 层的 `trap(struct trapframe *tf)` 以及 `print_trapframe()`、`exception_handler()`、`interrupt_handler()` 等函数能以统一结构访问这些信息，从而做出正确的分发、打印或修复（例如修改 `tf->epc` 跳过非法指令）。

### 为什么 RESTORE_ALL 没有逐一恢复 `stval`、`scause` 等 CSR？
- 恢复必要性视目标而定。该实现中只将 `sstatus` 和 `sepc` 写回 CSR（通过 `csrw sstatus, s1` 与 `csrw sepc, s2`），然后恢复通用寄存器并执行 `sret`。原因与考虑包括：

1. 恢复哪些 CSR 是“必要且足够”的
- 要返回到被打断的上下文（继续执行原程序），最关键的是：
  - 恢复 `sepc`（返回的指令地址），保证 `sret` 能正确跳回异常发生前或修改后的指令位置。
  - 恢复 `sstatus`（状态寄存器），恢复中断使能位与特权级等状态，保证返回时中断与特权状态一致。
- `scause` 和 `stval` 是“只读的异常信息寄存器”——它们提供关于异常的原因/信息，但并不决定返回后的行为（不影响 `sret` 的返回）。因此不强制要求恢复它们到CSR；恢复 `sepc` 和 `sstatus` 就足以把执行流和状态恢复到中断前的可执行状态。

2. 恢复 CSR 到硬件 CSR 中并非总是必要
- 将 `scause`/`stval` 写回 CSR（硬件寄存器）在大多数情形下没有必要，因为这些寄存器的主要用途是在异常发生时由内核读取并记录到 trapframe，供内核分析/打印/处理。异常处理完成后，它们不需要再放回硬件 CSR，除非有特别的理由（比如在返回之前硬件或外部监控需要继续读取到同样的值）。
- 同时，操作（写回）CSR 可能带来副作用或额外开销。保持实现最小化，只恢复必要寄存器更简洁高效。

3. trapframe 的持久记录与调试
- 即便不写回 `stval`/`scause` 到硬件 CSR，内核已将这些值存到了 `trapframe` 的栈上并可由 C 层访问（例如 `print_trapframe(tf)` 打印出 `tf->badvaddr`、`tf->cause` 等），这对于调试与异常处理是充分的。
- 如果需要内核在返回前改变某个 CSR（例如故意更改 `sepc` 或 `sstatus`）以改变返回行为，RESTORE_ALL 已处理这些“必须写回”的 CSR。

4. 设计简化与职责分离
- SAVE_ALL 的职责：把完整的上下文（含供内核分析的寄存器与 CSR）保存到栈，供 C 层查看并可能修改（例如修改 `tf->epc` 跳过故障指令）。
- RESTORE_ALL 的职责：把那些需要恢复到硬件以保证被打断线程/进程能正确继续执行的寄存器/CSR 写回（在此实现中为 `sstatus` 和 `sepc`），并恢复通用寄存器。
- `scause`/`stval` 等更偏“描述性/只读”的信息，保存方便内核处理，但通常无需被写回硬件。

### 举例说明
- 情形 A（正常中断/异常处理并返回）：内核读取 `scause`/`stval` 判断类型、可能修改 `sepc`（例如对非法指令跳过）或 `sstatus`，然后 RESTORE_ALL 把 `sepc`/`sstatus` 写回，执行 `sret` 返回，硬件的 `scause`/`stval` 的当前值无关紧要。
- 情形 B（需要记录或调试）：内核把 `scause`/`stval` 存到 `trapframe` 并调用 `print_trapframe()`。即使返回后硬件的 `scause` 已被覆盖或改变，内核仍然能通过保存的 `trapframe` 取得原始异常信息。

### 小结
- `csrw sscratch, sp` 把内核栈指针存入 `sscratch`，用于在异常处理期间保留一个固定位置指向当前上下文；`csrrw s0, sscratch, x0` 把旧 `sscratch` 读到 `s0` 并将 `sscratch` 清零，既保存了先前信息又标记当前进入内核异常处理。
- `SAVE_ALL` 中保存 `stval`、`scause` 等 CSR 的目的是把完整的异常上下文记录到栈上，便于 C 层统一访问、打印和分析。而 RESTORE_ALL 只恢复那些必须写回硬件以保证正确返回执行流与状态的 CSR（如 `sepc` 和 `sstatus`）；`scause`/`stval` 为“描述性/只读”信息，通常不需要在返回前写回硬件，因此不在 RESTORE_ALL 中恢复。
- 这种设计使得异常信息被安全保存用于内核处理/调试，同时仅恢复必要寄存器以降低开销并保证返回的正确性。






## 四、Challenge3：完善异常中断

### 1. 测试概述

#### 测试目标
验证操作系统异常处理机制能够正确捕获和处理：
- **非法指令异常**（Illegal Instruction）
- **断点异常**（Breakpoint）

#### 测试原理
通过内联汇编主动触发异常，验证异常处理程序能够：
- 正确识别异常类型
- 输出准确的异常信息
- 恢复程序正常执行

### 2. 测试代码

```c
void test_exceptions(void) {
    cprintf("\n===== Testing Exception Handlers =====\n");
    
    // 测试1: 非法指令异常
    cprintf("Test 1: Triggering illegal instruction exception...\n");
    asm volatile(".word 0x00000000\n"  // 明确的非法指令
                 "nop\n"               // 异常处理后继续执行
                 ::: "memory");
    
    cprintf("Illegal instruction test completed.\n\n");
    
    // 测试2: 断点异常  
    cprintf("Test 2: Triggering breakpoint exception...\n");
    asm volatile("ebreak\n"            // 断点指令
                 "nop\n"               // 异常处理后继续执行
                 ::: "memory");
    
    cprintf("Breakpoint test completed.\n\n");
    
    cprintf("===== All Exception Tests Finished =====\n\n");
}
```

### 3. 测试逻辑

#### 3.1 测试流程
```
开始测试 → 触发异常 → 异常处理 → 验证输出 → 继续执行 → 完成测试
```

#### 3.2 关键设计
- **`.word 0x00000000`**：明确的非法指令，强制触发异常
- **`ebreak`**：RISC-V标准断点指令
- **`nop`**：验证程序在异常处理后能继续执行
- **`::: "memory"`**：内存屏障，确保指令不被优化

### 4. 预期输出

```
===== Testing Exception Handlers =====
Test 1: Triggering illegal instruction exception...
Illegal instruction caught at 0x80200000
Exception type:Illegal instruction
Illegal instruction test completed.

Test 2: Triggering breakpoint exception...
ebreak caught at 0x80200004
Exception type: breakpoint
Breakpoint test completed.

===== All Exception Tests Finished =====
```

### 5. 验证要点

#### 5.1 功能验证
- 非法指令异常被正确捕获
- 断点异常被正确捕获  
- 异常地址准确显示
- 异常类型正确标识
- 程序能够继续执行

#### 5.2 异常处理机制
- **异常检测**：CPU自动检测非法指令和断点
- **上下文保存**：trapframe保存寄存器状态
- **异常分发**：根据cause字段路由到对应处理程序
- **指令跳过**：`epc += 4`跳过当前异常指令

### 6. 技术原理

#### 6.1 异常触发机制
```c
// 非法指令：CPU遇到无法解码的指令
.word 0x00000000

// 断点指令：调试用途的显式断点
ebreak
```

#### 6.2 处理恢复机制
```c
// 异常处理后跳过当前指令
tf->epc += 4;

// 继续执行下一条指令
nop
```

### 7. 总结

该测试通过主动触发异常验证了异常处理系统的：
- **正确性**：准确识别和处理两种异常类型


## 五、实验与OS原理对应的重要知识点
### （一）中断/异常处理机制
#### 1. OS原理知识点
- **中断与系统调用的关联**：设备相关操作需在CPU特权态执行，进程需通过系统调用请求操作系统代为完成设备操作，操作系统响应系统调用时会触发进程切换，是实现多进程并发的关键触发点之一。
- **中断对并发的支撑**：中断是捕获程序“临时不用CPU”的核心机制，当程序触发设备操作（需特权态执行）时，会通过中断进入内核态，操作系统可借此将CPU资源分配给其他就绪进程，提升CPU利用率。

#### 2. 实验知识点
- **中断处理流程实现**：实验以`__alltraps`作为中断/异常统一入口，通过`SAVE_ALL`宏将当前上下文（通用寄存器、关键控制状态寄存器）保存到栈上的`struct trapframe`结构中；随后通过`move a0, sp`将` trapframe`地址传递给C层` trap()`函数，`trap()`根据`tf->cause`判断中断或异常类型，分别分发至`interrupt_handler()`或`exception_handler()`处理；最终通过`__trapret`调用`RESTORE_ALL`恢复上下文，并执行`sret`指令返回中断前的执行流。
- **时钟中断具体处理**：在`interrupt_handler()`中，针对监督者模式定时器中断（`IRQ_S_TIMER`），实现了周期性处理逻辑：调用`clock_set_next_event()`设置下次中断触发时间，确保时钟中断持续产生；通过静态计数器`ticks`累计中断次数，每累计100次打印“100 ticks”并重置计数器；同时通过`num`计数器累计打印次数，当`num`达到10时调用`sbi_shutdown()`实现系统关机，验证了时钟中断驱动系统周期性任务的功能。

#### 3. 关系与理解
- **原理指导实验流程设计**：“中断触发进程切换与资源调度”的原理，决定了实验中中断处理流程必须包含“上下文保存-中断分发-上下文恢复”三个核心环节——只有完整保存当前进程上下文，才能确保中断处理后进程可继续执行；只有通过中断类型分发，才能针对性处理不同中断（如时钟中断、外设中断），这与原理中“中断是操作系统资源管理的触发枢纽”逻辑一致。
- **实验具象化原理中的特权态切换**：原理中“系统调用需从用户态切换至内核态”的抽象逻辑，在实验中通过具体代码落地：用户态调用`printf()`最终触发`write()`系统调用，系统调用本质是特殊异常，会触发CPU从用户态切换至监督者态（内核态），进入`__alltraps`处理流程；实验通过`sscratch`、`sstatus`等控制状态寄存器的操作，实现了特权态切换的状态记录与恢复，让原理中的“特权级隔离”从概念转化为可执行的代码逻辑。


### （二）进程上下文保存与恢复
#### 1. OS原理知识点
- **上下文切换的核心**：进程切换需满足“切换前保存上下文、切换后恢复上下文”的要求，上下文包含进程运行所需的寄存器值、CPU状态、内存地址空间信息；处理器状态由寄存器决定，程序状态由内存变量决定，在内存变量不被破坏的前提下，保存和恢复寄存器组即可实现进程的启停与切换。
- **PCB的核心作用**：进程控制块（PCB）是内核维护的进程状态记录，包含寄存器组（上下文）、进程状态、优先级、内存段指针等信息，多个进程的PCB以链表形式组织，上下文切换本质是对不同进程PCB中“寄存器组”的保存与恢复操作。

#### 2. 实验知识点
- **上下文保存载体：trapframe结构**：实验定义的`struct trapframe`（`trap.h`）是中断场景下的上下文存储载体，包含`struct pushregs`（存储x0~x31通用寄存器）和`status`、`epc`、`badvaddr`、`cause`等关键控制状态寄存器（CSR）信息，对应原理中PCB的“寄存器组”核心部分；`SAVE_ALL`宏通过固定偏移将寄存器和CSR值存入栈，构建` trapframe`，确保中断发生时进程状态不丢失。
- **上下文保存与恢复的指令实现**：`SAVE_ALL`宏通过`STORE`指令依次将x0~x31（除x2暂存栈指针）、`sstatus`、`sepc`、`stval`、`scause`等存入栈，且通过`csrrw s0, sscratch, x0`原子操作保存`sscratch`旧值；`RESTORE_ALL`宏通过`LOAD`指令反向恢复这些值，且刻意“最后恢复x2（sp）”，避免提前改变栈指针导致后续寄存器访问出错，严格遵循原理中“寄存器保存与恢复需保证状态一致性”的要求。

#### 3. 关系与理解
- **实验是原理的“中断场景子集实现”**：原理中“进程上下文切换”是通用概念，涵盖进程调度、中断、异常等多种触发场景；实验聚焦于“中断/异常场景”，仅实现了“单进程中断时的上下文保存与恢复”——当中断发生时，保存当前进程上下文至` trapframe`，处理完成后恢复上下文，确保进程可继续执行，这是原理中“进程上下文管理”的关键子集，为后续多进程调度场景下的完整上下文切换奠定基础。
- **trapframe与PCB的关联与差异**：实验中的` trapframe`是“临时上下文存储结构”，仅在中断处理期间存在于栈中，用于临时保存进程状态；原理中的PCB是“进程长期状态存储结构”，贯穿进程整个生命周期，包含更丰富的进程信息（如PID、优先级、内存段指针）。当中断处理涉及进程切换时，`trapframe`中的上下文会同步到对应进程的PCB中，实验虽未实现完整PCB链表，但` trapframe`的设计已覆盖PCB中“上下文存储”的核心功能，是原理在实验场景下的简化实现。


### （三）CPU特权级与状态管理
#### 1. OS原理知识点
- **特权级划分与隔离**：CPU通过特权级划分实现内核与用户程序的隔离，典型架构（如x86、MIPS、RISCV）均定义了不同特权级，其中内核态（高特权级）可执行特权指令（如设备控制、内存管理），用户态（低特权级）仅能执行普通指令；特权级切换是操作系统安全性的核心保障，用户程序需通过中断/系统调用进入内核态才能访问特权资源。
- **特权态的标识与切换**：内核通过控制状态寄存器（如RISCV的`sstatus`）记录当前特权级状态，例如`sstatus`的SPP位标识中断前的特权级；中断发生时CPU自动切换至内核态，中断返回时通过专用指令（如RISCV的`sret`）恢复原特权级，确保特权级状态在中断前后一致。

#### 2. 实验知识点
- **RISCV特权级相关CSR操作**：实验在`idt_init()`中通过`write_csr(sscratch, 0)`将监督者暂存寄存器（`sscratch`）置0，标识当前处于内核态处理异常，避免递归异常时混淆上下文来源；`trap_in_kernel()`函数通过`tf->status & SSTATUS_SPP`判断中断是否发生在内核态，对应原理中“特权级状态标识”的逻辑；`sret`指令（`__trapret`中）用于从内核态返回原特权级，自动恢复`sstatus`中的SPP位对应的特权状态，是特权级切换的关键指令。
- **特权指令的执行控制**：实验中用户态无法直接执行设备操作，需通过`printf()`→`write()`系统调用触发中断，进入内核态后由内核执行设备控制指令，体现原理中“特权指令仅能在内核态执行”的规则；`SAVE_ALL`和`RESTORE_ALL`宏对`sstatus`的保存与恢复，确保特权级状态在中断处理前后不丢失，避免因特权级异常导致系统崩溃。

#### 3. 关系与理解
- **实验聚焦特定架构的特权级实践**：原理覆盖多种架构的特权级设计（x86的4级、MIPS的2级、RISCV的3级），实验则针对RISCV架构，具体实现“监督者态（S态，内核态）与用户态（U态）”的切换与管理，将原理中“特权级隔离”的抽象概念，通过`sscratch`、`sstatus`、`sret`等具体寄存器和指令转化为可验证的代码，让原理中的“安全性隔离”有了实际载体。
- **特权级与中断处理的深度绑定**：原理中“中断是特权级切换的主要触发方式”，在实验中体现为：中断发生时CPU自动从用户态切换至S态，`SAVE_ALL`保存`sstatus`（含特权级信息），`RESTORE_ALL`恢复`sstatus`后，`sret`根据SPP位返回对应特权级，形成“中断触发特权级切换→处理特权任务→恢复特权级”的完整闭环，验证了原理中“特权级与中断处理相辅相成”的逻辑。


## 六、OS原理中重要但实验未对应的知识点
### （一）进程状态模型与调度算法
#### 1. OS原理知识点
- **进程状态分类与转换**：进程具有多种状态（运行、就绪、阻塞、新建、退出、挂起等），不同状态通过特定事件触发转换，例如“运行→就绪（时间片耗尽）”“运行→阻塞（等待设备事件）”“阻塞→就绪（等待事件发生）”；状态模型是操作系统管理进程的基础，通过状态分类实现进程的有序调度与资源分配。
- **进程调度核心逻辑**：操作系统通过调度算法（如时间片轮转、优先级调度）从就绪队列中选择“急需CPU”的进程，调度触发时机包括时钟中断、进程阻塞、进程退出等；调度的本质是对就绪队列中进程PCB的选择与上下文切换，是实现多进程并发的核心机制。

#### 2. 未对应原因
实验仅实现“单进程下的时钟中断处理”，未涉及多进程创建与管理：未定义PCB链表、就绪队列、阻塞队列等数据结构，无法实现进程状态分类与转换；无“多进程竞争CPU”场景，因此无需调度算法选择进程，仅通过时钟中断累计次数验证中断机制，未触及原理中的进程状态模型与调度逻辑。


### （二）进程与程序的区别与联系
#### 1. OS原理知识点
- **进程与程序的核心差异**：进程是动态的（程序的执行过程，有生命周期），程序是静态的（有序指令与数据的集合，可长期存储）；进程由程序、数据、PCB三部分组成，程序仅包含指令与数据；一个程序可对应多个进程（如多次运行记事本程序生成多个进程实例），多个进程实例间相互隔离（内存空间、数据独立）。
- **程序加载为进程的过程**：可执行程序需加载至内存（指令、数据入内存），并创建对应的PCB（记录进程状态、寄存器组、内存段指针），才能成为可执行的进程；操作系统通过加载器完成“程序→进程”的转换，是程序得以运行的关键步骤。

#### 2. 未对应原因
实验中无“程序加载为进程”的过程：未实现可执行程序（如`exe`）的加载逻辑，无进程创建接口，仅在 kernel 初始化时启动单一进程（无用户进程）；无多进程实例场景，无法验证“一个程序对应多个进程”及“进程隔离”的特性，因此原理中“进程与程序的区别与联系”未在实验中体现。


### （三）PCB的完整结构与组织方式
#### 1. OS原理知识点
- **PCB的完整内容**：PCB包含进程管理信息（PID、父进程指针、进程状态、优先级）、内存管理信息（代码段指针、数据段指针、栈段指针、页表基址）、文件管理信息（根目录、工作目录、文件描述符表）、上下文信息（寄存器组）等，是“进程的全景状态记录”，内核通过PCB掌控进程的所有信息。
- **PCB的组织方式**：所有进程的PCB以链表或表格形式存储，不同状态的进程PCB归入对应队列（如就绪队列存储就绪态PCB、阻塞队列存储阻塞态PCB、挂起队列存储挂起态PCB）；操作系统通过操作这些队列实现进程状态转换（如将阻塞进程PCB移入等待队列）与调度（如从就绪队列选择进程）。

#### 2. 未对应原因
实验仅定义`struct trapframe`（临时上下文存储），未定义完整PCB结构：缺少PID、父进程指针、内存段指针、文件描述符等关键字段；未实现PCB的组织方式（无就绪队列、阻塞队列等链表），仅在中断处理中临时保存上下文，无法通过PCB管理进程全生命周期信息，因此原理中“PCB的完整结构与组织方式”未在实验中体现。


### （四）挂起进程模型与内存交换
#### 1. OS原理知识点
- **挂起状态的核心作用**：挂起模型用于将长时间无法运行的进程（如等待低速设备的进程）换至外存，释放内存资源给活跃进程，目的包括提高CPU利用率（减小就绪队列长度，降低调度开销）、缓解内存紧张、便于进程调试；挂起状态分为就绪挂起（外存存储，进入内存即可运行）和等待挂起（外存存储，需等待事件发生）。
- **挂起与激活的状态转换**：挂起（Suspend）是“进程从内存转至外存”的操作，触发条件包括内存资源紧张、低优先级进程为高优先级进程让路；激活（Activate）是“进程从外存转至内存”的操作，触发条件包括内存空闲、挂起进程等待的事件发生；挂起与激活是操作系统实现内存与外存资源均衡的重要手段。

#### 2. 未对应原因
实验中无“内存与外存的交换机制”：未实现进程镜像（代码、数据）在内存与硬盘间的加载与换出逻辑，无外存管理相关接口；无“内存资源紧张”场景，所有代码与数据均在内存中运行，无需将进程挂起至外存，因此原理中的挂起进程模型与内存交换逻辑未在实验中体现。
