# 实验一

## 1. 设计实现过程

### 1. 内存分配
```c
struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
```
首先使用内核内存分配器`kmalloc`为进程控制块分配内存空间。

### 2. 字段初始化策略

**进程状态管理：**
```c
proc->state = PROC_UNINIT;
```
将进程状态初始化为`PROC_UNINIT`，表示这是一个新创建但尚未初始化的进程。

**标识符初始化：**
```c
proc->pid = -1;
```
将进程ID设置为-1，这是一个无效值，表示该进程尚未被分配正式的进程ID。

**运行统计：**
```c
proc->runs = 0;
```
运行次数初始化为0，记录进程被调度执行的次数。

**内核栈管理：**
```c
proc->kstack = 0;
```
内核栈指针初始化为0，表示尚未为进程分配内核栈空间。

**调度标志：**
```c
proc->need_resched = 0;
```
设置不需要重新调度，进程创建后不会立即要求调度器切换。

**进程关系：**
```c
proc->parent = NULL;
```
父进程指针设为NULL，创建时没有父进程。

**内存管理：**
```c
proc->mm = NULL;
```
内存管理结构初始化为NULL，对于内核线程可能不需要用户空间内存管理。

**执行上下文：**
```c
memset(&(proc->context), 0, sizeof(struct context));
```
将进程切换时的上下文信息全部清零，确保没有残留数据。

**中断处理：**
```c
proc->tf = NULL;
```
陷阱帧指针初始化为NULL，表示当前没有中断或异常上下文。

**地址空间：**
```c
proc->pgdir = boot_pgdir_pa;
```
页目录表基址设置为内核启动时的页目录物理地址，使新进程共享内核地址空间。

**标志和名称：**
```c
proc->flags = 0;
memset(proc->name, 0, PROC_NAME_LEN + 1);
```
进程标志清零，进程名称数组用0填充，确保字符串以空字符结尾。



## 2. struct context 
这个`struct context`是**RISC-V架构**下的**上下文结构体**，核心用途是保存/恢复程序执行状态（如进程切换、中断处理、函数调用嵌套时），其中的寄存器均为RISC-V的核心通用寄存器，且遵循“被调用者保存”规则（即函数调用时需保留原值，切换上下文必须保存这些寄存器）。

下面按寄存器类别拆解作用，结合内核开发场景（进程切换、中断处理）说明：

### 一、特殊功能寄存器（核心执行状态）
#### 1. `ra`（Return Address，返回地址寄存器）
- 作用：存储**函数调用后的返回地址**。
- 场景：当执行`call`指令调用函数时，CPU会自动将下一条指令的地址存入`ra`；函数执行完后，通过`ret`指令跳回`ra`指向的地址继续执行。
- 为什么要保存：进程切换或中断时，若不保存`ra`，切换回来后会找不到函数的返回地址，导致程序执行混乱。

#### 2. `sp`（Stack Pointer，栈指针寄存器）
- 作用：存储**当前栈的栈顶虚拟地址**，栈是函数调用时存储局部变量、函数参数、临时数据的核心内存区域。
- 场景：函数调用时`sp`会向下（低地址）移动分配栈空间，函数返回时`sp`向上（高地址）恢复；内核中进程切换时，每个进程有独立栈，必须保存`sp`才能恢复该进程的栈状态。
- 关键：`sp`是程序执行的“栈基准”，值丢失会导致栈访问错乱（如读写错误地址）。

### 二、保存寄存器（s0~s11，Saved Registers）
RISC-V规定：`s0~s11`属于“被调用者保存寄存器”——即**函数调用时，被调用函数不能随意覆盖这些寄存器的值**，若要使用必须先保存原值，返回前恢复。因此上下文切换时，这些寄存器必须被保存，否则切换回来后程序的中间数据会丢失。

每个`s`寄存器的具体用途（通用但有约定俗成的场景）：
#### 3. `s0`（常作为`fp`，Frame Pointer，帧指针寄存器）
- 作用：默认作为帧指针，指向当前函数栈帧的基地址（栈帧是函数调用时分配的独立栈空间）。
- 场景：通过`sp`（栈顶）和`fp`（栈基）可定位函数的局部变量、参数，方便调试和栈回溯（如打印函数调用栈）。
- 注：RISC-V允许省略`fp`，但内核开发中为了稳定性，通常会启用`fp`功能。

#### 4. `s1~s11`（通用保存寄存器）
- 作用：存储函数需要“持续使用”的数据，不会因调用其他函数而被覆盖。
- 场景：
  - 比如进程的核心状态（如当前任务的计数器、链表指针）、内核函数中的全局临时变量（需跨函数使用）；
  - 例：内核在处理进程切换时，会将进程的关键数据（如页表指针、状态标志）暂存到`s1~s11`，切换回来后再恢复。
- 特点：12个寄存器足够存储进程执行的核心上下文，确保切换后程序能无缝继续执行。

### 三、上下文结构体的核心用途
这个结构体通常用在以下场景：
1. **进程切换**：内核暂停当前进程时，将`ra`、`sp`、`s0~s11`的值存入该结构体；切换到新进程时，从其对应的`struct context`中恢复这些寄存器的值，新进程就能从上次暂停的位置继续执行。
2. **中断/异常处理**：中断发生时，内核会将当前程序的上下文存入该结构体，执行中断服务程序；中断处理完后，恢复上下文让程序继续运行。
3. **协程切换**：用户态协程或内核态轻量级线程切换时，通过该结构体保存/恢复执行状态（原理同进程切换）。

### 四、关键补充：为什么只保存这些寄存器？
RISC-V的寄存器分两类，另一类是“调用者保存寄存器”（如`a0~a7`、`t0~t6`），这类寄存器由调用函数负责保存，无需存入上下文结构体：
- 调用者保存寄存器：用于传递函数参数、临时计算，函数调用时可能被覆盖，无需跨进程/中断保存；
- 被调用者保存寄存器（`ra`、`sp`、`s0~s11`）：需跨函数/跨切换保留值，是上下文的核心。


## 3. struct *trapframe

### RISC-V 中的定义：
```c
struct trapframe {
    uint64_t kernel_satp;   // 内核页表地址
    uint64_t kernel_sp;     // 内核栈指针
    uint64_t kernel_trap;   // 内核陷阱处理函数
    uint64_t epc;           // 异常程序计数器
    uint64_t kernel_hartid; // 硬件线程ID
    uint64_t ra;            // 返回地址 (x1)
    uint64_t sp;            // 栈指针 (x2)
    uint64_t gp;            // 全局指针 (x3)
    uint64_t tp;            // 线程指针 (x4)
    uint64_t t0;            // 临时寄存器 (x5)
    uint64_t t1;            // 临时寄存器 (x6)
    uint64_t t2;            // 临时寄存器 (x7)
    uint64_t s0;            // 保存寄存器 (x8)
    uint64_t s1;            // 保存寄存器 (x9)
    uint64_t a0;            // 函数参数/返回值 (x10)
    uint64_t a1;            // 函数参数 (x11)
    uint64_t a2;            // 函数参数 (x12)
    uint64_t a3;            // 函数参数 (x13)
    uint64_t a4;            // 函数参数 (x14)
    uint64_t a5;            // 函数参数 (x15)
    uint64_t a6;            // 函数参数 (x16)
    uint64_t a7;            // 函数参数/系统调用号 (x17)
    uint64_t s2;            // 保存寄存器 (x18)
    uint64_t s3;            // 保存寄存器 (x19)
    uint64_t s4;            // 保存寄存器 (x20)
    uint64_t s5;            // 保存寄存器 (x21)
    uint64_t s6;            // 保存寄存器 (x22)
    uint64_t s7;            // 保存寄存器 (x23)
    uint64_t s8;            // 保存寄存器 (x24)
    uint64_t s9;            // 保存寄存器 (x25)
    uint64_t s10;           // 保存寄存器 (x26)
    uint64_t s11;           // 保存寄存器 (x27)
    uint64_t t3;            // 临时寄存器 (x28)
    uint64_t t4;            // 临时寄存器 (x29)
    uint64_t t5;            // 临时寄存器 (x30)
    uint64_t t6;            // 临时寄存器 (x31)
    // 可能还有状态寄存器等
};
```

### 含义和作用：
- **完整陷阱现场**：保存异常/中断发生时的完整CPU状态
- **特权级切换**：处理用户态和内核态之间的切换
- **系统调用支持**：通过 a0-a7 寄存器传递系统调用参数




## 4. 两者在 RISC-V 中的区别

| 特性 | struct context | struct trapframe |
|------|----------------|------------------|
| **寄存器范围** | 只保存 callee-saved 寄存器 | 保存所有通用寄存器 + 特殊寄存器 |
| **使用场景** | 主动的进程调度切换 | 被动的异常/中断处理 |
| **位置** | 进程控制块内嵌 | 指向内核栈中的位置 |
| **初始化** | alloc_proc() 中清零 | 在进程创建时设置 |



# 二、proc_run函数实验报告

## 函数功能
`proc_run`函数用于将指定的进程切换到CPU上运行，实现进程上下文切换。

## 函数实现分析

### 1. 函数原型
```c
void proc_run(struct proc_struct *proc)
```

### 2. 执行流程

**步骤1：检查是否需要切换**
```c
if (proc != current)
```
只有当目标进程不是当前正在运行的进程时才执行切换操作。

**步骤2：保存中断状态**
```c
bool intr_flag;
struct proc_struct *prev = current;
local_intr_save(intr_flag);
```
- 保存当前中断状态到`intr_flag`
- 保存当前进程指针到`prev`

**步骤3：切换当前进程指针**
```c
current = proc;
```
将全局当前进程指针指向新的目标进程。

**步骤4：切换页表**
```c
lsatp((unsigned int)proc->pgdir);
```
加载新进程的页目录表基址到`satp`寄存器，完成地址空间切换。

**步骤5：执行上下文切换**
```c
switch_to(&prev->context, &proc->context);
```
- 保存原进程的上下文到`prev->context`
- 恢复新进程的上下文从`proc->context`
- 该函数执行完成后，CPU将从新进程的上下文继续执行

**步骤6：恢复中断状态**
```c
local_intr_restore(intr_flag);
```
恢复之前保存的中断状态。

## 关键特性

### 1. 原子性保证
通过`local_intr_save`和`local_intr_restore`确保上下文切换过程的原子性，防止在切换过程中被中断打断。

### 2. 完整的上下文保存
- 处理器状态通过`switch_to`保存
- 地址空间通过`lsatp`切换
- 进程控制块指针`current`更新

### 3. 架构无关性
通过`switch_to`函数封装了架构相关的上下文切换细节，保持了接口的统一性。

## 问题回答

**在本实验的执行过程中，创建且运行了几个内核线程？**

根据代码分析，在实验执行过程中创建并运行了**2个内核线程**：

1. **idleproc（空闲线程）**
   - PID = 0
   - 名称："idle"
   - 状态：PROC_RUNNABLE
   - 功能：系统空闲时运行，负责进程调度

2. **initproc（初始化线程）**
   - PID = 1  
   - 名称："init"
   - 由`kernel_thread(init_main, "Hello world!!", 0)`创建
   - 执行`init_main`函数，打印初始化信息

这两个线程通过`proc_init()`函数在系统初始化时创建，并通过`proc_run`函数进行调度和执行。



# 扩展练习

## 一、开关中断机制分析

### local_intr_save和local_intr_restore实现原理

#### 1. 宏定义分析
```c
#define local_intr_save(x)      do { x = __intr_save(); } while (0)
#define local_intr_restore(x)   __intr_restore(x);
```

#### 2. 底层函数实现
```c
static inline bool __intr_save(void) {
    // 读取当前sstatus寄存器中的SIE位
    if (read_csr(sstatus) & SSTATUS_SIE) {
        // 如果中断使能，则禁用中断
        intr_disable();
        return 1;  // 返回true表示之前中断是开启的
    }
    return 0;  // 返回false表示之前中断已经是关闭的
}

static inline void __intr_restore(bool flag) {
    // 根据保存的状态恢复中断
    if (flag) {
        intr_enable();  // 恢复中断使能
    }
    // 如果flag为false，说明之前中断就是关闭的，不需要操作
}
```

#### 3. 中断使能/禁用具体实现
```c
// 禁用中断 - 清除sstatus寄存器的SIE位
#define intr_disable() do { clear_csr(sstatus, SSTATUS_SIE); } while (0)

// 使能中断 - 设置sstatus寄存器的SIE位  
#define intr_enable() do { set_csr(sstatus, SSTATUS_SIE); } while (0)
```

#### 4. 工作机制详解

**保存中断状态过程：**
1. 读取当前`sstatus`寄存器中的SIE(Supervisor Interrupt Enable)位
2. 如果SIE=1（中断使能），则清除SIE位禁用中断，并返回1
3. 如果SIE=0（中断已禁用），直接返回0
4. 返回值保存在`intr_flag`中，记录中断之前的状态

**恢复中断状态过程：**
1. 检查保存的`intr_flag`值
2. 如果`intr_flag=1`，说明之前中断是使能的，重新设置SIE位
3. 如果`intr_flag=0`，说明之前中断就是禁用的，不进行任何操作

#### 5. 在proc_run中的应用意义
```c
bool intr_flag;
local_intr_save(intr_flag);  // 保存并禁用中断

// 关键的上下文切换操作
current = proc;
lsatp((unsigned int)proc->pgdir);
switch_to(&prev->context, &proc->context);

local_intr_restore(intr_flag);  // 恢复之前的中断状态
```

**重要性：**
- **原子性保证**：防止在切换当前进程指针、页表和上下文时被中断打断
- **数据一致性**：确保进程状态转换的完整性
- **死锁预防**：避免在持有锁的情况下被中断处理程序抢占

## 二、分页模式工作原理与get_pte函数分析

### 1. RISC-V分页模式比较

| 特性 | SV32 | SV39 | SV48 |
|------|------|------|------|
| **虚拟地址位数** | 32位 | 39位 | 48位 |
| **物理地址位数** | 34位 | 56位 | 56位 |
| **页表级数** | 2级 | 3级 | 4级 |
| **页大小** | 4KB | 4KB | 4KB |
| **页表项大小** | 4字节 | 8字节 | 8字节 |
| **VPN划分** | VPN[1]和VPN[0] | VPN[2]、VPN[1]、VPN[0] | VPN[3]、VPN[2]、VPN[1]、VPN[0] |

### 2. get_pte函数中相似代码段分析

#### 代码段1（处理前几级页目录）：
```c
pde_t *pdep = &pgdir[PDX1(la)];  // 获取一级页目录项
if (!(*pdep & PTE_V)) {          // 检查有效位
    struct Page *page;
    if (!create || (page = alloc_page()) == NULL) {
        return NULL;
    }
    set_page_ref(page, 1);
    uintptr_t pa = page2pa(page);
    memset(KADDR(pa), 0, PGSIZE);
    *pdep = pte_create(pa, PTE_U | PTE_V);
}
```

#### 代码段2（处理最后一级页目录）：
```c
pde_t *pdep = &pde[PDX0(la)];    // 获取末级页目录项  
if (!(*pdep & PTE_V)) {          // 检查有效位
    struct Page *page;
    if (!create || (page = alloc_page()) == NULL) {
        return NULL;
    }
    set_page_ref(page, 1);
    uintptr_t pa = page2pa(page);
    memset(KADDR(pa), 0, PGSIZE);
    *pdep = pte_create(pa, PTE_U | PTE_V);
}
```

### 3. 代码相似性原因

**根本原因：多级页表结构的递归性**

1. **统一的页表项结构**：
   - 所有级别的页表项都有相同的格式（V、R、W、X等标志位）
   - 都使用相同的有效性检查逻辑（`PTE_V`）

2. **相同的分配逻辑**：
   - 都需要检查页表项是否存在
   - 都需要在不存在时分配新的物理页
   - 都需要初始化新分配的页表并设置引用计数

3. **递归的遍历机制**：
   - 不同级别的页表遍历遵循相同的模式
   - 每级都是：获取索引→检查有效性→必要时分配→继续下一级

4. **硬件设计的一致性**：
   - RISC-V的各种分页模式在设计理念上保持一致
   - SV32、SV39、SV48只是级数和地址位数不同，基本操作相同

### 4. 功能合并与拆分分析

#### 当前合并设计的优点：

1. **性能优化**：
   ```c
   // 单次遍历同时完成查找和分配，避免重复的页表遍历
   pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create) {
       // 在遍历过程中直接处理缺失的页表项
   }
   ```

2. **原子性保证**：
   - 查找和分配在同一个函数中完成，避免竞争条件
   - 确保页表结构的完整性

3. **代码简洁性**：
   - 减少函数调用开销
   - 逻辑集中，便于理解整个页表操作流程

#### 拆分成两个函数的潜在优点：

1. **单一职责原则**：
   ```c
   // 方案：拆分为两个函数
   pte_t *find_pte(pde_t *pgdir, uintptr_t la);          // 纯查找
   pte_t *alloc_pte(pde_t *pgdir, uintptr_t la);         // 分配页表项
   ```

2. **更好的错误处理**：
   - 可以区分"页表项不存在"和"分配失败"两种错误
   - 调用方可以根据具体情况进行不同处理

3. **代码复用性**：
   - `find_pte`可以在只读场景下使用
   - `alloc_pte`可以用于预分配页表项

4. **测试友好性**：
   - 可以单独测试查找功能和分配功能
   - 更容易模拟各种边界情况

#### 推荐方案：

**保持当前合并设计，但增加辅助函数**：

```c
// 保持现有的get_pte函数不变
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create) {
    // 现有实现
}

// 新增纯查找函数供特殊场景使用
pte_t *find_pte_only(pde_t *pgdir, uintptr_t la) {
    return get_pte(pgdir, la, 0);  // create = false
}
```

**理由**：
1. 性能是关键考虑因素，合并设计减少了不必要的遍历
2. 大多数使用场景都需要"查找或创建"的语义
3. 通过参数控制行为已经提供了足够的灵活性
4. 保持向后兼容性

### 5. 总结

get_pte函数中的相似代码段体现了多级页表系统的递归本质，这种设计在不同分页模式间具有很好的一致性。当前的合并设计在性能和实用性方面具有优势，虽然在一定程度上违反了单一职责原则，但在操作系统内核这种对性能要求极高的环境中是合理的权衡。
