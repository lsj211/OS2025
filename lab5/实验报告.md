## 练习一

### 1、
设计实现要点（kern/process/proc.c）：在 load_icode 第 6 步，清零 trapframe 后设置 sp=USTACKTOP、epc=elf->e_entry、status=(sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE。保证 sret 直接返回到用户态、PC 指向程序入口、SP 在用户栈顶，从而运行新程序。前面已创建新 mm、页表、映射 ELF 各段和用户栈，并切换 satp 为新页表。

### 2、
user_main 到用户程序第一条指令的经过：
init_main 调 kernel_thread(user_main,NULL,0) 创建内核线程，do_fork 只分配 proc_struct+内核栈，mm=NULL，context.ra=forkret，置 RUNNABLE。
调度选中该线程：proc_run 切换页表+上下文，进入 forkret→forkrets，sret 到 kernel_thread_entry，调用 user_main（仍内核态）。
user_main 通过 KERNEL_EXECVE 触发 SYS_exec，进入 do_execve/load_icode，创建并安装新地址空间，写好 trapframe（入口/栈/用户态标志）。
系统调用尾部的 sret（同一次陷入返回）直接用新的 trapframe 切到用户态，PC=ELF 入口，SP=用户栈顶，开始执行用户程序第一条指令。
若 exec 成功，不会回到 kernel_execve 的 cprintf；若失败，则返回内核态继续执行那里的错误打印。

## 测试修改
下面是本次调试修改：

内核异常/页故障处理

kern/trap/trap.c：为取指/读/写页故障调用 do_pgfault；无法修复的用户页故障打印信息后 do_exit(-E_KILLED)；内核页故障仍 panic。补充了 #include <proc.h> 以访问当前进程。
定时器中断逻辑调整：使用全局 ticks 计数，每 TICK_NUM 打印一次并置当前进程 need_resched=1，避免无谓循环。
进程初始化/调度

kern/process/proc.c：初始化进程时补全 exit_code/wait_state 及亲缘指针；lsatp 改为使用 64 位 pgdir 值。
do_fork：清理父进程 wait_state，设置子进程亲缘指针，改用 set_links 维护链表/计数，简化插入流程。
页故障服务例程

kern/mm/vmm.c：新增 do_pgfault，验证 VMA 合法性后为缺页分配并清零一页，按 VMA 权限建页表；否则返回错误。
kern/mm/vmm.h：导出 do_pgfault 声明。