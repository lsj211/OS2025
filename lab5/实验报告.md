## 练习一

### 1、
设计实现要点（kern/process/proc.c）：在 load_icode 第 6 步，清零 trapframe 后设置 sp=USTACKTOP、epc=elf->e_entry、status=(sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE。保证 sret 直接返回到用户态、PC 指向程序入口、SP 在用户栈顶，从而运行新程序。前面已创建新 mm、页表、映射 ELF 各段和用户栈，并切换 satp 为新页表。

### 2、
user_main 到用户程序第一条指令的经过：
init_main 调 kernel_thread(user_main,NULL,0) 创建内核线程，do_fork 只分配 proc_struct+内核栈，mm=NULL，context.ra=forkret，置 RUNNABLE。
调度选中该线程：proc_run 切换页表+上下文，进入 forkret→forkrets，sret 到 kernel_thread_entry，调用 user_main（仍内核态）。
user_main 通过 KERNEL_EXECVE 触发 SYS_exec，进入 do_execve/load_icode，创建并安装新地址空间，写好 trapframe（入口/栈/用户态标志）。
系统调用尾部的 sret（同一次陷入返回）直接用新的 trapframe 切到用户态，PC=ELF 入口，SP=用户栈顶，开始执行用户程序第一条指令。
若 exec 成功，不会回到 kernel_execve 的 cprintf；若失败，则返回内核态继续执行那里的错误打印。

## 测试修改
下面是本次调试修改：

内核异常/页故障处理

kern/trap/trap.c：为取指/读/写页故障调用 do_pgfault；无法修复的用户页故障打印信息后 do_exit(-E_KILLED)；内核页故障仍 panic。补充了 #include <proc.h> 以访问当前进程。
定时器中断逻辑调整：使用全局 ticks 计数，每 TICK_NUM 打印一次并置当前进程 need_resched=1，避免无谓循环。
进程初始化/调度

kern/process/proc.c：初始化进程时补全 exit_code/wait_state 及亲缘指针；lsatp 改为使用 64 位 pgdir 值。
do_fork：清理父进程 wait_state，设置子进程亲缘指针，改用 set_links 维护链表/计数，简化插入流程。
页故障服务例程

kern/mm/vmm.c：新增 do_pgfault，验证 VMA 合法性后为缺页分配并清零一页，按 VMA 权限建页表；否则返回错误。
kern/mm/vmm.h：导出 do_pgfault 声明。


## Challenge：1. 设计概述

Copy-on-Write (COW) 是一种内存管理优化技术。在 `fork()` 系统调用时，内核并不立即为子进程复制父进程的物理内存页，而是让父子进程共享同一份物理页，并将这些页面的权限设置为**只读 (Read-Only)**。只有当任一进程尝试**修改 (Write)** 这些页面时，CPU 触发缺页异常，内核捕获该异常后，才真正分配新的物理页并复制数据，从而实现“写时复制”。

### 1.1 核心目标
1.  **减少内存开销**：多个进程共享读取同一份数据。
2.  **加速进程创建**：`fork` 时只需复制页表，无需复制物理内存。

---

## 2. 状态转换说明 (有限状态自动机)

我们可以将物理页的状态视为一个有限状态机 (FSM)。

### 状态定义
1.  **FREE**: 空闲状态，引用计数 `ref = 0`。
2.  **EXCLUSIVE (独占)**: 被一个进程独占，可读可写。`ref = 1`, `PTE_W = 1`, `PTE_COW = 0`。
3.  **SHARED (共享/COW)**: 被多个进程共享，只读。`ref > 1`, `PTE_W = 0`, `PTE_COW = 1`。

### 状态转换事件

1.  **Alloc (分配)**:
    *   `FREE` -> `EXCLUSIVE`: 进程申请新页。

2.  **Fork (进程创建)**:
    *   `EXCLUSIVE` -> `SHARED`: 父进程 fork。原物理页引用计数加 1 (`ref=2`)。父子进程 PTE 均设为 `Read-Only + COW`。
    *   `SHARED` -> `SHARED`: 再次 fork。物理页引用计数加 1 (`ref++`)。新子进程 PTE 设为 `Read-Only + COW`。

3.  **Write Fault (写异常)**:
    *   `SHARED` -> `EXCLUSIVE` (对于当前进程):
        *   触发 `do_pgfault`。
        *   **Action**: 分配新物理页 (`New Page`)。
        *   **Copy**: 将旧页内容拷贝到新页。
        *   **Map**: 当前进程 PTE 指向 `New Page`，设置为 `Read-Write`，清除 `COW`。
        *   **Deref**: 旧页引用计数减 1。
    *   *注：如果旧页引用计数减为 1，旧页实际上也回到了 EXCLUSIVE 逻辑状态（虽然 PTE 可能仍保留 COW 标，直到下次写异常或优化处理）。*

4.  **Exit/Exec (进程退出/重置)**:
    *   `SHARED` -> `SHARED` (ref--): 某一个共享进程退出，引用计数减 1。
    *   `SHARED` -> `FREE`: 最后一个使用该页的进程退出，引用计数减为 0，回收物理页。

---

## 3. 实现源码

### 3.1 宏定义 (`kern/mm/mmu.h`)
定义 COW 标志位，使用 RISC-V 页表项的保留位（第 8 位）。
```c
#define PTE_COW 0x100  // 使用第8位（RSW字段）作为COW标志
```

### 3.2 Fork 阶段 (`kern/mm/pmm.c`)
修改 `copy_range` 函数，实现页表共享而非拷贝。

```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) {
    // ... 遍历页表 ...
    if (*ptep & PTE_V) {
        struct Page *page = pte2page(*ptep);
        uint32_t perm = (*ptep & PTE_USER);
        
        if (perm & PTE_W) {
            // 【核心逻辑】
            // 1. 去除写权限 (Disable Write)
            // 2. 标记为 COW (Set COW bit)
            perm = (perm & ~PTE_W) | PTE_COW;
            
            // 3. 为子进程建立映射 (引用计数+1)
            int ret = page_insert(to, page, start, perm);
            if (ret != 0) return ret;
            
            // 4. 更新父进程页表项 (引用计数不变，因为 page_insert 并没有移除父进程的映射)
            //    注意：这里直接修改 PTE 需要手动刷新 TLB
            *ptep = (*ptep & ~PTE_W) | PTE_COW;
            tlb_invalidate(from, start);
        } else {
            // 原本就是只读的页，直接共享，不设 COW
            page_insert(to, page, start, perm);
        }
    }
    // ...
}
```

### 3.3 缺页处理阶段 (`kern/mm/vmm.c`)
修改 `do_pgfault` 函数，处理写时复制。

```c
int do_pgfault(struct mm_struct *mm, uint32_t cause, uintptr_t addr) {
    // ... 获取 PTE ...
    
    // 检查是否有效且存在
    if (ptep != NULL && (*ptep & PTE_V)) {
        // 【核心逻辑】
        // 判断条件：页表项有 COW 标记 且 异常原因是写操作 (STORE)
        if ((*ptep & PTE_COW) && (cause == CAUSE_STORE_PAGE_FAULT)) {
            struct Page *old_page = pte2page(*ptep);
            
            // 1. 分配新物理页
            struct Page *new_page = alloc_page();
            if (new_page == NULL) return -E_NO_MEM;
            
            // 2. 拷贝数据 (Deep Copy)
            memcpy(page2kva(new_page), page2kva(old_page), PGSIZE);
            
            // 3. 生成新权限：恢复写权限，清除 COW 标记
            uint32_t new_perm = (perm | PTE_W) & ~PTE_COW;
            
            // 4. 建立新映射 (page_insert 会自动处理旧页的引用计数减少)
            if (page_insert(mm->pgdir, new_page, la, new_perm) != 0) {
                free_page(new_page);
                return -E_NO_MEM;
            }
            return 0; // 处理成功
        }
    }
    // ...
}
```

### 3.4 辅助修改
*   **`kern/trap/trap.c`**: 确保 `CAUSE_STORE_PAGE_FAULT` 调用 `do_pgfault`。
*   **`kern/process/proc.c`**: 修复 `do_fork` 中的 `set_links` 和 `alloc_proc` 初始化，防止空指针引用。

---

## 4. 测试用例 (`user/cow.c`)

该测试程序验证：
1.  Fork 后子进程能读取父进程数据。
2.  子进程写入数据时触发 COW，拥有独立副本。
3.  父进程数据不受子进程写入影响。

```c
#include <ulib.h>
#include <stdio.h>
#include <stdlib.h>

static char buf[4096] = { 'A', 0 }; // 占用一个物理页

int main(void) {
    int pid = fork();
    
    if (pid == 0) {
        // 子进程
        // 此时 buf 指向父进程的物理页 (Read-Only, COW)
        // 执行写操作 -> 触发 Page Fault -> 内核复制页面 -> 变为可写
        buf[0] = 'B'; 
        cprintf("[child] buf=%c\n", buf[0]); // 应输出 B
        exit(0);
    } else {
        // 父进程
        wait(); // 等待子进程结束
        // 检查父进程内存是否被修改
        cprintf("[parent] buf=%c\n", buf[0]); // 应输出 A
        exit(0);
    }
    return 0;
}
```

## 5. 运行结果

执行 `make run-cow`：

```text
kernel_execve: pid = 2, name = "cow".
[child] buf=B
[parent] buf=A
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:555:
    initproc exit.
```

*   **[child] buf=B**: 子进程成功写入并读取了自己的副本。
*   **[parent] buf=A**: 父进程的数据保持原样，证明物理页已分离。
*   **initproc exit**: 系统正常结束。
