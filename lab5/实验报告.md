## 练习一

### 1、
设计实现要点（kern/process/proc.c）：在 load_icode 第 6 步，清零 trapframe 后设置 sp=USTACKTOP、epc=elf->e_entry、status=(sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE。保证 sret 直接返回到用户态、PC 指向程序入口、SP 在用户栈顶，从而运行新程序。前面已创建新 mm、页表、映射 ELF 各段和用户栈，并切换 satp 为新页表。

### 2、
user_main 到用户程序第一条指令的经过：
init_main 调 kernel_thread(user_main,NULL,0) 创建内核线程，do_fork 只分配 proc_struct+内核栈，mm=NULL，context.ra=forkret，置 RUNNABLE。
调度选中该线程：proc_run 切换页表+上下文，进入 forkret→forkrets，sret 到 kernel_thread_entry，调用 user_main（仍内核态）。
user_main 通过 KERNEL_EXECVE 触发 SYS_exec，进入 do_execve/load_icode，创建并安装新地址空间，写好 trapframe（入口/栈/用户态标志）。
系统调用尾部的 sret（同一次陷入返回）直接用新的 trapframe 切到用户态，PC=ELF 入口，SP=用户栈顶，开始执行用户程序第一条指令。
若 exec 成功，不会回到 kernel_execve 的 cprintf；若失败，则返回内核态继续执行那里的错误打印。