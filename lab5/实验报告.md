## 练习一

### 1、
设计实现要点（kern/process/proc.c）：在 load_icode 第 6 步，清零 trapframe 后设置 sp=USTACKTOP、epc=elf->e_entry、status=(sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE。保证 sret 直接返回到用户态、PC 指向程序入口、SP 在用户栈顶，从而运行新程序。前面已创建新 mm、页表、映射 ELF 各段和用户栈，并切换 satp 为新页表。

### 2、
user_main 到用户程序第一条指令的经过：
init_main 调 kernel_thread(user_main,NULL,0) 创建内核线程，do_fork 只分配 proc_struct+内核栈，mm=NULL，context.ra=forkret，置 RUNNABLE。
调度选中该线程：proc_run 切换页表+上下文，进入 forkret→forkrets，sret 到 kernel_thread_entry，调用 user_main（仍内核态）。
user_main 通过 KERNEL_EXECVE 触发 SYS_exec，进入 do_execve/load_icode，创建并安装新地址空间，写好 trapframe（入口/栈/用户态标志）。
系统调用尾部的 sret（同一次陷入返回）直接用新的 trapframe 切到用户态，PC=ELF 入口，SP=用户栈顶，开始执行用户程序第一条指令。
若 exec 成功，不会回到 kernel_execve 的 cprintf；若失败，则返回内核态继续执行那里的错误打印。

## 测试修改
下面是本次调试修改：

内核异常/页故障处理

kern/trap/trap.c：为取指/读/写页故障调用 do_pgfault；无法修复的用户页故障打印信息后 do_exit(-E_KILLED)；内核页故障仍 panic。补充了 #include <proc.h> 以访问当前进程。
定时器中断逻辑调整：使用全局 ticks 计数，每 TICK_NUM 打印一次并置当前进程 need_resched=1，避免无谓循环。
进程初始化/调度

kern/process/proc.c：初始化进程时补全 exit_code/wait_state 及亲缘指针；lsatp 改为使用 64 位 pgdir 值。
do_fork：清理父进程 wait_state，设置子进程亲缘指针，改用 set_links 维护链表/计数，简化插入流程。
页故障服务例程

kern/mm/vmm.c：新增 do_pgfault，验证 VMA 合法性后为缺页分配并清零一页，按 VMA 权限建页表；否则返回错误。
kern/mm/vmm.h：导出 do_pgfault 声明。




## 练习二：父进程复制自己的内存空间给子进程

### 实现思路
按照实验要求，立即拷贝父进程的有效用户页到子进程。copy_range 遍历父页表项时，对每个有效页：
1. 分配一页新物理页 npage。
2. 用 page2kva 得到父页和新页的内核虚拟地址。
3. memcpy 拷贝整页内容（PGSIZE）。
4. page_insert(to, npage, start, perm) 将新页按父页权限映射到子进程的相同虚拟地址。
5. 若失败，释放新页并返回错误码。

### 核心修改
在`copy_range`函数对应位置添加代码：
```c
struct Page *npage = alloc_page();
if (npage == NULL) {
    return -E_NO_MEM;
}
void *src_kvaddr = page2kva(page);
void *dst_kvaddr = page2kva(npage);
memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
ret = page_insert(to, npage, start, perm);
if (ret != 0) {
    free_page(npage);
    return ret;
}
```
### 补充说明
- 按注释的四步：找到源/目的页内核虚拟地址，拷贝一页，建立新映射。
- 每个子页独立分配并映射，父子地址空间互不影响。
- 失败路径释放新页，避免内存泄漏。
- 关于COW机制的设计，我们在下一小节COW实现时详细给出。



## Challenge：1. 设计概述

Copy-on-Write (COW) 是一种内存管理优化技术。在 `fork()` 系统调用时，内核并不立即为子进程复制父进程的物理内存页，而是让父子进程共享同一份物理页，并将这些页面的权限设置为**只读 (Read-Only)**。只有当任一进程尝试**修改 (Write)** 这些页面时，CPU 触发缺页异常，内核捕获该异常后，才真正分配新的物理页并复制数据，从而实现“写时复制”。

### 1.1 核心目标
1.  **减少内存开销**：多个进程共享读取同一份数据。
2.  **加速进程创建**：`fork` 时只需复制页表，无需复制物理内存。

---

## 2. 状态转换说明 (有限状态自动机)

我们可以将物理页的状态视为一个有限状态机 (FSM)。

### 状态定义
1.  **FREE**: 空闲状态，引用计数 `ref = 0`。
2.  **EXCLUSIVE (独占)**: 被一个进程独占，可读可写。`ref = 1`, `PTE_W = 1`, `PTE_COW = 0`。
3.  **SHARED (共享/COW)**: 被多个进程共享，只读。`ref > 1`, `PTE_W = 0`, `PTE_COW = 1`。

### 状态转换事件

1.  **Alloc (分配)**:
    *   `FREE` -> `EXCLUSIVE`: 进程申请新页。

2.  **Fork (进程创建)**:
    *   `EXCLUSIVE` -> `SHARED`: 父进程 fork。原物理页引用计数加 1 (`ref=2`)。父子进程 PTE 均设为 `Read-Only + COW`。
    *   `SHARED` -> `SHARED`: 再次 fork。物理页引用计数加 1 (`ref++`)。新子进程 PTE 设为 `Read-Only + COW`。

3.  **Write Fault (写异常)**:
    *   `SHARED` -> `EXCLUSIVE` (对于当前进程):
        *   触发 `do_pgfault`。
        *   **Action**: 分配新物理页 (`New Page`)。
        *   **Copy**: 将旧页内容拷贝到新页。
        *   **Map**: 当前进程 PTE 指向 `New Page`，设置为 `Read-Write`，清除 `COW`。
        *   **Deref**: 旧页引用计数减 1。
    *   *注：如果旧页引用计数减为 1，旧页实际上也回到了 EXCLUSIVE 逻辑状态（虽然 PTE 可能仍保留 COW 标，直到下次写异常或优化处理）。*

4.  **Exit/Exec (进程退出/重置)**:
    *   `SHARED` -> `SHARED` (ref--): 某一个共享进程退出，引用计数减 1。
    *   `SHARED` -> `FREE`: 最后一个使用该页的进程退出，引用计数减为 0，回收物理页。

---

## 3. 实现源码

### 3.1 宏定义 (`kern/mm/mmu.h`)
定义 COW 标志位，使用 RISC-V 页表项的保留位（第 8 位）。
```c
#define PTE_COW 0x100  // 使用第8位（RSW字段）作为COW标志
```

### 3.2 Fork 阶段 (`kern/mm/pmm.c`)
修改 `copy_range` 函数，实现页表共享而非拷贝。

```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) {
    // ... 遍历页表 ...
    if (*ptep & PTE_V) {
        struct Page *page = pte2page(*ptep);
        uint32_t perm = (*ptep & PTE_USER);
        
        if (perm & PTE_W) {
            // 【核心逻辑】
            // 1. 去除写权限 (Disable Write)
            // 2. 标记为 COW (Set COW bit)
            perm = (perm & ~PTE_W) | PTE_COW;
            
            // 3. 为子进程建立映射 (引用计数+1)
            int ret = page_insert(to, page, start, perm);
            if (ret != 0) return ret;
            
            // 4. 更新父进程页表项 (引用计数不变，因为 page_insert 并没有移除父进程的映射)
            //    注意：这里直接修改 PTE 需要手动刷新 TLB
            *ptep = (*ptep & ~PTE_W) | PTE_COW;
            tlb_invalidate(from, start);
        } else {
            // 原本就是只读的页，直接共享，不设 COW
            page_insert(to, page, start, perm);
        }
    }
    // ...
}
```

### 3.3 缺页处理阶段 (`kern/mm/vmm.c`)
修改 `do_pgfault` 函数，处理写时复制。

```c
int do_pgfault(struct mm_struct *mm, uint32_t cause, uintptr_t addr) {
    // ... 获取 PTE ...
    
    // 检查是否有效且存在
    if (ptep != NULL && (*ptep & PTE_V)) {
        // 【核心逻辑】
        // 判断条件：页表项有 COW 标记 且 异常原因是写操作 (STORE)
        if ((*ptep & PTE_COW) && (cause == CAUSE_STORE_PAGE_FAULT)) {
            struct Page *old_page = pte2page(*ptep);
            
            // 1. 分配新物理页
            struct Page *new_page = alloc_page();
            if (new_page == NULL) return -E_NO_MEM;
            
            // 2. 拷贝数据 (Deep Copy)
            memcpy(page2kva(new_page), page2kva(old_page), PGSIZE);
            
            // 3. 生成新权限：恢复写权限，清除 COW 标记
            uint32_t new_perm = (perm | PTE_W) & ~PTE_COW;
            
            // 4. 建立新映射 (page_insert 会自动处理旧页的引用计数减少)
            if (page_insert(mm->pgdir, new_page, la, new_perm) != 0) {
                free_page(new_page);
                return -E_NO_MEM;
            }
            return 0; // 处理成功
        }
    }
    // ...
}
```

### 3.4 辅助修改
*   **`kern/trap/trap.c`**: 确保 `CAUSE_STORE_PAGE_FAULT` 调用 `do_pgfault`。
*   **`kern/process/proc.c`**: 修复 `do_fork` 中的 `set_links` 和 `alloc_proc` 初始化，防止空指针引用。

---

## 4. 测试用例 (`user/cow.c`)

该测试程序验证：
1.  Fork 后子进程能读取父进程数据。
2.  子进程写入数据时触发 COW，拥有独立副本。
3.  父进程数据不受子进程写入影响。

```c
#include <ulib.h>
#include <stdio.h>
#include <stdlib.h>

static char buf[4096] = { 'A', 0 }; // 占用一个物理页

int main(void) {
    int pid = fork();
    
    if (pid == 0) {
        // 子进程
        // 此时 buf 指向父进程的物理页 (Read-Only, COW)
        // 执行写操作 -> 触发 Page Fault -> 内核复制页面 -> 变为可写
        buf[0] = 'B'; 
        cprintf("[child] buf=%c\n", buf[0]); // 应输出 B
        exit(0);
    } else {
        // 父进程
        wait(); // 等待子进程结束
        // 检查父进程内存是否被修改
        cprintf("[parent] buf=%c\n", buf[0]); // 应输出 A
        exit(0);
    }
    return 0;
}
```

## 5. 运行结果

执行 `make run-cow`：

```text
kernel_execve: pid = 2, name = "cow".
[child] buf=B
[parent] buf=A
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:555:
    initproc exit.
```

*   **[child] buf=B**: 子进程成功写入并读取了自己的副本。
*   **[parent] buf=A**: 父进程的数据保持原样，证明物理页已分离。
*   **initproc exit**: 系统正常结束。



## LAB5分支任务：gdb 调试系统调用以及返回

### 1.双 gdb 调试系统调用核心流程

（1）核心目标：通过双重 GDB（调试 ucore 内核 + 调试 QEMU 模拟器）观察：

- 用户态程序触发系统调用（ecall 指令）
- QEMU 如何模拟硬件处理 ecall，完成特权级切换（U 态→S 态）
- 内核处理系统调用后，通过 sret 指令返回用户态
- QEMU 如何模拟 sret 指令的特权级切换逻辑

（2）准备工作：


  理解关键文件和调试逻辑：
  
   - 用户程序：lab5 的用户程序“链接进内核”（如 exit.c），编译后生成 `obj/__user_exit.out`（含符号表）。  
   - 系统调用触发点：`user/libs/syscall.c` 中的 `syscall` 函数，用内联汇编的 `ecall` 指令触发系统调用。  
   - 双重 GDB 分工：  
     * GDB1（终端 B）：调试 ucore 内核 + 用户程序（跟踪 U 态→S 态→U 态代码流程）。  
     * GDB2（终端 C）：调试 QEMU 模拟器（跟踪 QEMU 如何模拟 ecall/sret 指令）。

下面进行具体调试流程：


### 2.终端 A：启动 QEMU，挂起等待 gdb

<!-- - 输入： -->
```sh
make debug
```
<!-- - 输出：QEMU 以 `-s -S` 启动（OpenSBI/ucore 启动信息略），此时挂起等待 gdb 连接。 -->

### 3.终端 C：附加 QEMU，布置 QEMU 侧断点（翻译/执行层）

1. 先找到 QEMU 的 PID 并附加：
   ```
   pgrep -f qemu-system-riscv64   # 查看 PID
   1342
   sudo gdb
   (gdb) attach 1342
   ```
   （显示附加成功，并列出线程，输出较长。）

2. 关闭 SIGPIPE 打断，清理旧断点并设置 ecall/sret 相关断点：
   - 关闭 SIGPIPE 打断。输入：
     ```gdb
     (gdb) handle SIGPIPE nostop noprint
     ```
     输出：
     ```
     Signal        Stop      Print   Pass to program       Description
     SIGPIPE       No        No      Yes          Broken pipe
     ```
   - 清除断点，防止之间的尝试干扰。输入：
     ```gdb
     (gdb) delete
     ```
     <!-- 输出：`Delete all breakpoints? (y or n)`（如无旧断点可略过确认）。 -->
   - 添加trans_ecall断点。输入：
     ```gdb
     (gdb) b trans_ecall
     ```
     输出：
     ```
     Breakpoint 1 at 0x5608ce91f87b: file /home/op_user/qemu-4.1.1/target/riscv/insn_trans/trans_privileged.inc.c, line 24.
     ```
   - 添加trans_sret断点。输入：
     ```gdb
     (gdb) b trans_sret
     ```
     输出：
     ```
     Breakpoint 2 at 0x5608ce91f918: file /home/op_user/qemu-4.1.1/target/riscv/insn_trans/trans_privileged.inc.c, line 46.
     ```
   - 添加helper_sret断点。输入：
     ```gdb
     (gdb) b helper_sret
     ```
     输出：
     ```
     Breakpoint 3 at 0x5608ce922256: file /home/op_user/qemu-4.1.1/target/riscv/op_helper.c, line 76.
     ```
   - 终端C放行。输入：
     ```gdb
     (gdb) c
     ```
     输出：（等待 guest 触发）。
     ```
     Continuing.
     ```

  其中，`trans_ecall`、`trans_sret` 断点观察 TCG 翻译阶段，`helper_sret` 观察 sret 执行阶段。

### 4.终端 B：连接 guest gdb，加载符号，下用户/内核断点

1. 启动 riscv gdb 并加载用户符号：
   ```gdb
   make gdb
   (gdb) add-symbol-file obj/__user_exit.out
   add symbol table from file "obj/__user_exit.out"
   (y or n) y
   Reading symbols from obj/__user_exit.out...
   (gdb) set remotetimeout unlimited
   ```
2. 下断点：用户态 syscall、内核 trap 入口和返回：
   ```gdb
   (gdb) b user/libs/syscall.c:19
   Breakpoint 1 at 0x8000f4: file user/libs/syscall.c, line 19.
   (gdb) b __alltraps
   Breakpoint 2 at 0xffffffffc0200e6c: file kern/trap/trapentry.S, line 123.
   (gdb) b __trapret
   Breakpoint 3 at 0xffffffffc0200edc: file kern/trap/trapentry.S, line 131.
   (gdb) c
   Continuing.

   Breakpoint 1, syscall (num=num@entry=30)
       at user/libs/syscall.c:19
   19          asm volatile (
   ```
   说明：用户符号加载成功，已停在用户态 syscall 内联汇编。

### 5.单步到 ecall，触发 QEMU 侧 ecall 翻译断点

- 在终端 B，查看当前位置：
    ```gdb
  (gdb) x/7i $pc
  => 0x8000f6 <syscall+34>:
      ld  a1,40(sp)
     0x8000f8 <syscall+36>:
      ld  a2,48(sp)
     0x8000fa <syscall+38>:
      ld  a3,56(sp)
     0x8000fc <syscall+40>:
      ld  a4,64(sp)
     0x8000fe <syscall+42>:
      ld  a5,72(sp)
     0x800100 <syscall+44>:       ecall
     0x800104 <syscall+48>:
      sd  a0,28(sp)
    ```
    然后持续单步si直到ecall前：

    ```
  (gdb) x/7i $pc
  => 0x800100 <syscall+44>:       ecall
     0x800104 <syscall+48>:       sd      a0,28(sp)
     0x800108 <syscall+52>:       lw      a0,28(sp)
     0x80010a <syscall+54>:       addi    sp,sp,144
     0x80010c <syscall+56>:       ret
     0x80010e <sys_exit>:         mv      a1,a0
     0x800110 <sys_exit+2>:       li      a0,1
    ```
  此时参数已正常装入 a1–a5，PC 停在 ecall 前一条。

- 继续si单步执行，终端 C 显示命中了 trans_ecall断点：
    ```gdb
  (gdb) c
  Continuing.
  [Switching to Thread 0x7c1405d7d6c0 (LWP 1045)]

  Thread 2 "qemu-system-ris" hit Breakpoint 1, trans_ecall (ctx=0x7c1405d7c7d0,
  a=0x7c1405d7c6d0)
  at /home/op_user/qemu-4.1.1/target/riscv/insn_trans/trans_privileged.inc.c:24
  24 generate_exception(ctx, RISCV_EXCP_U_ECALL);
    ```
    我们查看此时的截断信息：

    ```
  (gdb) i r sp
  sp             0x7c1405d7c6a0      0x7c1405d7c6a0
    ```
  此时说明TCG 翻译阶段捕获 ecall，生成 U 级异常并退出当前 TB。然后我们在终端C放行。

### 6.进入内核 trap，快进到 sret 前

- 终端C放行之后，终端 B 继续向下执行，命中断点 __alltraps：
  ```gdb
  (gdb) c
  Continuing.

  Breakpoint 2, __alltraps ()
      at kern/trap/trapentry.S:123
  123         SAVE_ALL
  (gdb) i r sp
  sp             0xffffffffc0209ff0       0xffffffffc0209ff0
  (gdb) bt
  #0  __alltraps () at kern/trap/trapentry.S:123
  #1  0xffffffffc02000a2 in kern_init () at kern/init/init.c:42
  #2  0x0000000080000a02 in ?? ()
  ```
  说明此时已切到内核栈。

<!-- - 在 trap 内单步si到trapret： -->

- 查看此时位置：

  ```gdb
  (gdb) x/7i $pc
  => 0xffffffffc0200dc8 <trap>:
      auipc       a4,0xa5
     0xffffffffc0200dcc <trap+4>:
      ld  a4,744(a4)
     0xffffffffc0200dd0 <trap+8>:
      ld  a1,280(a0)
     0xffffffffc0200dd4 <trap+12>:
      beqz        a4,0xffffffffc0200e2c <trap+100>
     0xffffffffc0200dd6 <trap+14>:
      ld  a2,256(a0)
     0xffffffffc0200dda <trap+18>:
      ld  a6,160(a4)
     0xffffffffc0200dde <trap+22>:
      addi        sp,sp,-32

    ```

接下来我们在 trap 内执行到trapret。向下查找多条指令，直到找到trapret处的pc，为节省过多单步调试步骤，我们直接快进到该pc处：

```
  (gdb) until *0xffffffffc0200ebc
```
此时命中断点__trapret：
```
  Breakpoint 3, __trapret ()
      at kern/trap/trapentry.S:131
  131         RESTORE_ALL
```
<!-- 我们查看此处的截断信息：
```
  (gdb) i r sp
  sp             0xffffffffc0209ed0       0xffffffffc0209ed0
  (gdb) bt
  #0  __trapret () at kern/trap/trapentry.S:131
  #1  0xffffffffc0200ebc in __alltraps ()
      at kern/trap/trapentry.S:126
``` -->

接下来我们执行到sret。此处向下查找多条指令还找不到sret指令，应该是距离sret较远，我们通过反汇编查找sret的pc位置，并直接快进过去：

```gdb
  (gdb) disassemble __trapret  
  ...
  0xffffffffc0200f12 <+86>:    sret
  (gdb) until *0xffffffffc0200f12
```
补充说明：此过程中我们先快进到 __trapret，确认栈已调整到 0xffffffffc0209ed0，验证 RESTORE_ALL 之前栈和寄存器都已经回到预期位置，然后再快进到sret指令，避免出现偏差。

### 7.观测 sret 翻译与执行

<!-- - 终端 C 命中 trans_sret： -->

- 终端B快进到sret并执行后，终端C命中trans_sret：

    ```gdb
  (gdb) c
  Continuing.

  Thread 2 "qemu-system-ris" hit Breakpoint 2, trans_sret (ctx=0x7c1405d7c7d0,
  a=0x7c1405d7c6d0)
  at /home/op_user/qemu-4.1.1/target/riscv/insn_trans/trans_privileged.inc.c:46
  46          tcg_gen_movi_tl(cpu_pc, ctx->base.pc_next);

    ```
    我们查看此时截断处的相关信息：

    ```gdb
  (gdb) i r sp
  sp             0x7c1405d7c6a0      0x7c1405d7c6a0
  (gdb) bt（简略版）
  #0 trans_sret
  #1 decode_insn32
  #2 decode_opc / riscv_tr_translate_insn
  #3 translator_loop
  #4 gen_intermediate_code
  #5 tb_gen_code
  #6 tb_find
  #7 cpu_exec
  #8 tcg_cpu_exec
  #9 qemu_tcg_cpu_thread_fn
  #10 start_thread / clone
    ```
  可见，sret 翻译阶段捕获，链路为译码→TB 生成→TB 运行→线程入口，确认返回路径的 TCG 翻译已被触达。

- 终端 C 继续，命中 helper_sret：

    我们在终端C放行，放行后命中断点 helper_sret：

  ```gdb
  (gdb) c
  Continuing.

  Thread 2 "qemu-system-ris" hit Breakpoint 3, helper_sret (env=0x5608ed6b9040,
  cpu_pc_deb=18446744072637910802)
  at /home/op_user/qemu-4.1.1/target/riscv/op_helper.c:76
  76          if (!(env->priv >= PRV_S)) {
  ```
    我们查看此时截断处的相关信息：

    ```
  (gdb) i r sp
  sp             0x7c1405d7c3d0      0x7c1405d7c3d0
  (gdb) bt（简略版）
  #0 helper_sret
  #1 code_gen_buffer
  #2 cpu_tb_exec
  #3 cpu_loop_exec_tb
  #4 cpu_exec
  #5 tcg_cpu_exec
  #6 qemu_tcg_cpu_thread_fn
  #7 pthread_start / clone
    ```
  可见，helper_sret 执行阶段被捕获，链路为 TB 执行→循环执行→CPU 执行→线程入口，完成特权校验与 mstatus/sepc 恢复，准备切回用户态。


  最后我们在终端C中continue放行，发现终端B和终端C的断点反复触发，这应该是因为我们在终端 B 和终端 C 都设置了持久断点，我们尝试disable掉这些断点，发现终端B中 ucore 已回到用户态，且为sret的下一条指令，说明系统调用完整流程结束。

到此，用户态 ecall → 内核 trap → sret 返回用户态的翻译和执行关键路径均已捕获并解释。


### 8.终端 C 断点对应源码与关键流程解析

- 断点设置：
  ```
  (gdb) handle SIGPIPE nostop noprint
  (gdb) delete                 
  (gdb) b trans_ecall
  Breakpoint 1 at 0x5608ce91f87b: file /home/op_user/qemu-4.1.1/target/riscv/insn_trans/trans_privileged.inc.c, line 24.
  (gdb) b trans_sret
  Breakpoint 2 at 0x5608ce91f918: file /home/op_user/qemu-4.1.1/target/riscv/insn_trans/trans_privileged.inc.c, line 46.
  (gdb) b helper_sret
  Breakpoint 3 at 0x5608ce922256: file /home/op_user/qemu-4.1.1/target/riscv/op_helper.c, line 76.
  ```

- 说明与分析：
    我们设置了翻译/执行链路中的关键断点：
    - `trans_ecall`：TCG 翻译 U/S/M 模 ecall 时调用 `generate_exception` 的入口；
    - `trans_sret`：TCG 翻译 sret，设置下一条 PC 的翻译入口；
    - `helper_sret`：实际执行 sret 的 helper，检查特权级、更新 PC/寄存器；
  <!-- - 后续命中时在终端 C 记录 `i r sp`、回溯后 `c` 放行，与终端 B 的 trap/sret 单步对应。 -->

  设置好断点之后，我们具体点开每个断点处对应的 qemu 源码进行分析。

- 源码与流程：
  - `trans_ecall`（/target/riscv/insn_trans/trans_privileged.inc.c:24）
    ```c++
    static bool trans_ecall(DisasContext *ctx, arg_ecall *a) {
        /* always generates U-level ECALL, fixed in do_interrupt handler */
        generate_exception(ctx, RISCV_EXCP_U_ECALL);
        exit_tb(ctx); /* no chaining */
        ctx->base.is_jmp = DISAS_NORETURN;
        return true;
    }
    ```
    - 译码期调用 `generate_exception` 抛出 U 模 ecall;
    - 并用 `exit_tb`/`DISAS_NORETURN` 终止当前 TB，强制走异常路径（对应 trans_ecall 断点）。

  - `trans_sret`（/target/riscv/insn_trans/trans_privileged.inc.c:46）
    ```c++
    static bool trans_sret(DisasContext *ctx, arg_sret *a) {
        tcg_gen_movi_tl(cpu_pc, ctx->base.pc_next);
        if (has_ext(ctx, RVS)) {
            gen_helper_sret(cpu_pc, cpu_env, cpu_pc);
            exit_tb(ctx); /* no chaining */
            ctx->base.is_jmp = DISAS_NORETURN;
        } else {
            return false;
        }
        return true;
    }
    ```
    - 先写入下一条 PC（`tcg_gen_movi_tl`）;
    - 再生成调用 `helper_sret` 的 TCG 代码；
    - 最后 `exit_tb`/`DISAS_NORETURN` 结束 TB，保证跳入 helper_sret 处理特权切换（对应 trans_sret 断点）。

  - `helper_sret`（/target/riscv/op_helper.c:76）
    ```c++
    target_ulong helper_sret(CPURISCVState *env, target_ulong cpu_pc_deb) {
        if (!(env->priv >= PRV_S)) {
            riscv_raise_exception(env, RISCV_EXCP_ILLEGAL_INST, GETPC());
        }
        target_ulong retpc = env->sepc;
        if (!riscv_has_ext(env, RVC) && (retpc & 0x3)) {
            riscv_raise_exception(env, RISCV_EXCP_INST_ADDR_MIS, GETPC());
        }
        if (env->priv_ver >= PRIV_VERSION_1_10_0 &&
            get_field(env->mstatus, MSTATUS_TSR)) {
            riscv_raise_exception(env, RISCV_EXCP_ILLEGAL_INST, GETPC());
        }

        target_ulong mstatus = env->mstatus;
        target_ulong prev_priv = get_field(mstatus, MSTATUS_SPP);
        mstatus = set_field(mstatus,
            env->priv_ver >= PRIV_VERSION_1_10_0 ?
            MSTATUS_SIE : MSTATUS_UIE << prev_priv,
            get_field(mstatus, MSTATUS_SPIE));
        mstatus = set_field(mstatus, MSTATUS_SPIE, 0);
        mstatus = set_field(mstatus, MSTATUS_SPP, PRV_U);
        riscv_cpu_set_mode(env, prev_priv);
        env->mstatus = mstatus;

        return retpc;
    }
    ```
    - 先做特权/对齐/TSR 校验，不满足则抛异常；
    - `retpc=sepc` 取回返回地址；
    - `set_field` 恢复/清空 SPIE/SIE、清 SPP 为 U；
    - `riscv_cpu_set_mode` 切换特权并写回 mstatus；
    - 返回 retpc 供跳转，完成 S→U（对应 helper_sret 断点）。

- 综合分析：
  - 翻译链路：trans_ecall 直接生成异常退出 TB；trans_sret 翻译 sret，调用 helper_sret 完成特权切换并退出 TB。
  - 执行链路：helper_sret 检查特权/对齐/TSR，更新 mstatus 和模式，返回 sepc，完成从 S 态返回 U 态。
  - 断点顺序：先命中 trans_ecall（进入内核），内核 trap 处理，命中 trans_sret → helper_sret（返回路径），实现从 U→S→U 的完整观测。
<!-- - 输入（终端 C 重新设置断点）：
  ```
  (gdb) handle SIGPIPE nostop noprint
  Signal        Stop      Print   Pass to program       Description
  SIGPIPE       No        No      Yes          Broken pipe
  (gdb) delete
  (gdb) b trans_ecall
  Breakpoint 1 at 0x5608ce91f87b: file /home/op_user/qemu-4.1.1/target/riscv/insn_trans/trans_privileged.inc.c, line 24.
  (gdb) b trans_sret
  Breakpoint 2 at 0x5608ce91f918: file /home/op_user/qemu-4.1.1/target/riscv/insn_trans/trans_privileged.inc.c, line 46.
  (gdb) b helper_sret
  Breakpoint 3 at 0x5608ce922256: file /home/op_user/qemu-4.1.1/target/riscv/op_helper.c, line 76.
  ``` -->



### 9.流程梳理与要求覆盖
- 三终端分工：A 启动 QEMU；C attach端口，下 `trans_ecall`/`trans_sret`/`helper_sret`断点；B 连接 stub（先 target remote，再下断点）。
- 关键断点顺序：用户态 `user/libs/syscall.c:19` → ecall 前单步；C 命中 `trans_ecall`；B 命中 `__alltraps` → `trap` → `__trapret`，在 sret 前下断点；C 依次命中 `trans_sret`、`helper_sret`。
- TCG 翻译/执行路径：`trans_ecall` 生成异常、退出 TB；`trans_sret` 生成 sret 翻译，调用 helper；`helper_sret` 检查特权/对齐/TSR，更新 mstatus 和模式，返回 sepc。已观察到翻译与执行两个阶段，满足“ecall 和 sret 的处理”与 “TCG Translation” 的实验要求。
- 返回链路：终端 B 在 sret 处单步，终端 C 先命中 `trans_sret`（翻译）再命中 `helper_sret`（执行），完整覆盖 U→S→U。

### 10.“抓马”细节与心得
- 端口/进程误杀：`target remote` 提示 Kill 时必须选 n，选了y就会三端断开，不得不重新进行三端重启流程，很悲催。
<!-- - 符号缺失：无符号 QEMU 无法用符号或行号断点，只能算基址+偏移；建议固定用带符号的 `/home/wangy1/qemu/build/qemu-system-riscv64`。 -->
- 调试技巧：在翻译/执行断点处记录 `i r sp`；`until`/`finish` 快速跳到 `__trapret`；`b *<sret 地址>` 精准命中返回点。
- 大模型帮助：确认需 `add-symbol-file obj/__user_exit.out` 才能在 B 侧下用户断点；指明 QEMU 源码中的 ecall/sret 处理路径与 TCG 机制。
