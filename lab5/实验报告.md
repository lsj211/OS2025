## 一、练习一

#### 1、
设计实现要点（kern/process/proc.c）：在 load_icode 第 6 步，清零 trapframe 后设置 sp=USTACKTOP、epc=elf->e_entry、status=(sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE。保证 sret 直接返回到用户态、PC 指向程序入口、SP 在用户栈顶，从而运行新程序。前面已创建新 mm、页表、映射 ELF 各段和用户栈，并切换 satp 为新页表。

#### 2、
user_main 到用户程序第一条指令的经过：
init_main 调 kernel_thread(user_main,NULL,0) 创建内核线程，do_fork 只分配 proc_struct+内核栈，mm=NULL，context.ra=forkret，置 RUNNABLE。
调度选中该线程：proc_run 切换页表+上下文，进入 forkret→forkrets，sret 到 kernel_thread_entry，调用 user_main（仍内核态）。
user_main 通过 KERNEL_EXECVE 触发 SYS_exec，进入 do_execve/load_icode，创建并安装新地址空间，写好 trapframe（入口/栈/用户态标志）。
系统调用尾部的 sret（同一次陷入返回）直接用新的 trapframe 切到用户态，PC=ELF 入口，SP=用户栈顶，开始执行用户程序第一条指令。
若 exec 成功，不会回到 kernel_execve 的 cprintf；若失败，则返回内核态继续执行那里的错误打印。

### 测试修改
下面是本次调试修改：

内核异常/页故障处理

kern/trap/trap.c：为取指/读/写页故障调用 do_pgfault；无法修复的用户页故障打印信息后 do_exit(-E_KILLED)；内核页故障仍 panic。补充了 #include <proc.h> 以访问当前进程。
定时器中断逻辑调整：使用全局 ticks 计数，每 TICK_NUM 打印一次并置当前进程 need_resched=1，避免无谓循环。
进程初始化/调度

kern/process/proc.c：初始化进程时补全 exit_code/wait_state 及亲缘指针；lsatp 改为使用 64 位 pgdir 值。
do_fork：清理父进程 wait_state，设置子进程亲缘指针，改用 set_links 维护链表/计数，简化插入流程。
页故障服务例程

kern/mm/vmm.c：新增 do_pgfault，验证 VMA 合法性后为缺页分配并清零一页，按 VMA 权限建页表；否则返回错误。
kern/mm/vmm.h：导出 do_pgfault 声明。




## 二、练习二：父进程复制自己的内存空间给子进程

### 实现思路
按照实验要求，立即拷贝父进程的有效用户页到子进程。copy_range 遍历父页表项时，对每个有效页：
1. 分配一页新物理页 npage。
2. 用 page2kva 得到父页和新页的内核虚拟地址。
3. memcpy 拷贝整页内容（PGSIZE）。
4. page_insert(to, npage, start, perm) 将新页按父页权限映射到子进程的相同虚拟地址。
5. 若失败，释放新页并返回错误码。

### 核心修改
在`copy_range`函数对应位置添加代码：
```c
struct Page *npage = alloc_page();
if (npage == NULL) {
    return -E_NO_MEM;
}
void *src_kvaddr = page2kva(page);
void *dst_kvaddr = page2kva(npage);
memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
ret = page_insert(to, npage, start, perm);
if (ret != 0) {
    free_page(npage);
    return ret;
}
```
### 补充说明
- 按注释的四步：找到源/目的页内核虚拟地址，拷贝一页，建立新映射。
- 每个子页独立分配并映射，父子地址空间互不影响。
- 失败路径释放新页，避免内存泄漏。
- 关于COW机制的设计，我们在下一小节COW实现时详细给出。



## 三、Challenge：
## 1. 设计概述

Copy-on-Write (COW) 是一种内存管理优化技术。在 `fork()` 系统调用时，内核并不立即为子进程复制父进程的物理内存页，而是让父子进程共享同一份物理页，并将这些页面的权限设置为**只读 (Read-Only)**。只有当任一进程尝试**修改 (Write)** 这些页面时，CPU 触发缺页异常，内核捕获该异常后，才真正分配新的物理页并复制数据，从而实现“写时复制”。

### 1.1 核心目标
1.  **减少内存开销**：多个进程共享读取同一份数据。
2.  **加速进程创建**：`fork` 时只需复制页表，无需复制物理内存。

---

## 2. 状态转换说明 (有限状态自动机)

我们可以将物理页的状态视为一个有限状态机 (FSM)。

### 状态定义
1.  **FREE**: 空闲状态，引用计数 `ref = 0`。
2.  **EXCLUSIVE (独占)**: 被一个进程独占，可读可写。`ref = 1`, `PTE_W = 1`, `PTE_COW = 0`。
3.  **SHARED (共享/COW)**: 被多个进程共享，只读。`ref > 1`, `PTE_W = 0`, `PTE_COW = 1`。

### 状态转换事件

1.  **Alloc (分配)**:
    *   `FREE` -> `EXCLUSIVE`: 进程申请新页。

2.  **Fork (进程创建)**:
    *   `EXCLUSIVE` -> `SHARED`: 父进程 fork。原物理页引用计数加 1 (`ref=2`)。父子进程 PTE 均设为 `Read-Only + COW`。
    *   `SHARED` -> `SHARED`: 再次 fork。物理页引用计数加 1 (`ref++`)。新子进程 PTE 设为 `Read-Only + COW`。

3.  **Write Fault (写异常)**:
    *   `SHARED` -> `EXCLUSIVE` (对于当前进程):
        *   触发 `do_pgfault`。
        *   **Action**: 分配新物理页 (`New Page`)。
        *   **Copy**: 将旧页内容拷贝到新页。
        *   **Map**: 当前进程 PTE 指向 `New Page`，设置为 `Read-Write`，清除 `COW`。
        *   **Deref**: 旧页引用计数减 1。
    *   *注：如果旧页引用计数减为 1，旧页实际上也回到了 EXCLUSIVE 逻辑状态（虽然 PTE 可能仍保留 COW 标，直到下次写异常或优化处理）。*

4.  **Exit/Exec (进程退出/重置)**:
    *   `SHARED` -> `SHARED` (ref--): 某一个共享进程退出，引用计数减 1。
    *   `SHARED` -> `FREE`: 最后一个使用该页的进程退出，引用计数减为 0，回收物理页。

---

## 3. 实现源码

### 3.1 宏定义 (`kern/mm/mmu.h`)
定义 COW 标志位，使用 RISC-V 页表项的保留位（第 8 位）。
```c
#define PTE_COW 0x100  // 使用第8位（RSW字段）作为COW标志
```

### 3.2 Fork 阶段 (`kern/mm/pmm.c`)
修改 `copy_range` 函数，实现页表共享而非拷贝。

```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) {
    // ... 遍历页表 ...
    if (*ptep & PTE_V) {
        struct Page *page = pte2page(*ptep);
        uint32_t perm = (*ptep & PTE_USER);
        
        if (perm & PTE_W) {
            // 【核心逻辑】
            // 1. 去除写权限 (Disable Write)
            // 2. 标记为 COW (Set COW bit)
            perm = (perm & ~PTE_W) | PTE_COW;
            
            // 3. 为子进程建立映射 (引用计数+1)
            int ret = page_insert(to, page, start, perm);
            if (ret != 0) return ret;
            
            // 4. 更新父进程页表项 (引用计数不变，因为 page_insert 并没有移除父进程的映射)
            //    注意：这里直接修改 PTE 需要手动刷新 TLB
            *ptep = (*ptep & ~PTE_W) | PTE_COW;
            tlb_invalidate(from, start);
        } else {
            // 原本就是只读的页，直接共享，不设 COW
            page_insert(to, page, start, perm);
        }
    }
    // ...
}
```

### 3.3 缺页处理阶段 (`kern/mm/vmm.c`)
修改 `do_pgfault` 函数，处理写时复制。

```c
int do_pgfault(struct mm_struct *mm, uint32_t cause, uintptr_t addr) {
    // ... 获取 PTE ...
    
    // 检查是否有效且存在
    if (ptep != NULL && (*ptep & PTE_V)) {
        // 【核心逻辑】
        // 判断条件：页表项有 COW 标记 且 异常原因是写操作 (STORE)
        if ((*ptep & PTE_COW) && (cause == CAUSE_STORE_PAGE_FAULT)) {
            struct Page *old_page = pte2page(*ptep);
            
            // 1. 分配新物理页
            struct Page *new_page = alloc_page();
            if (new_page == NULL) return -E_NO_MEM;
            
            // 2. 拷贝数据 (Deep Copy)
            memcpy(page2kva(new_page), page2kva(old_page), PGSIZE);
            
            // 3. 生成新权限：恢复写权限，清除 COW 标记
            uint32_t new_perm = (perm | PTE_W) & ~PTE_COW;
            
            // 4. 建立新映射 (page_insert 会自动处理旧页的引用计数减少)
            if (page_insert(mm->pgdir, new_page, la, new_perm) != 0) {
                free_page(new_page);
                return -E_NO_MEM;
            }
            return 0; // 处理成功
        }
    }
    // ...
}
```

### 3.4 辅助修改
*   **`kern/trap/trap.c`**: 确保 `CAUSE_STORE_PAGE_FAULT` 调用 `do_pgfault`。
*   **`kern/process/proc.c`**: 修复 `do_fork` 中的 `set_links` 和 `alloc_proc` 初始化，防止空指针引用。

---

## 4. 测试用例 (`user/cow.c`)

该测试程序验证：
1.  Fork 后子进程能读取父进程数据。
2.  子进程写入数据时触发 COW，拥有独立副本。
3.  父进程数据不受子进程写入影响。

```c
#include <ulib.h>
#include <stdio.h>
#include <stdlib.h>

static char buf[4096] = { 'A', 0 }; // 占用一个物理页

int main(void) {
    int pid = fork();
    
    if (pid == 0) {
        // 子进程
        // 此时 buf 指向父进程的物理页 (Read-Only, COW)
        // 执行写操作 -> 触发 Page Fault -> 内核复制页面 -> 变为可写
        buf[0] = 'B'; 
        cprintf("[child] buf=%c\n", buf[0]); // 应输出 B
        exit(0);
    } else {
        // 父进程
        wait(); // 等待子进程结束
        // 检查父进程内存是否被修改
        cprintf("[parent] buf=%c\n", buf[0]); // 应输出 A
        exit(0);
    }
    return 0;
}
```

## 5. 运行结果

执行 `make run-cow`：

```text
kernel_execve: pid = 2, name = "cow".
[child] buf=B
[parent] buf=A
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:555:
    initproc exit.
```

*   **[child] buf=B**: 子进程成功写入并读取了自己的副本。
*   **[parent] buf=A**: 父进程的数据保持原样，证明物理页已分离。
*   **initproc exit**: 系统正常结束。

## 6. Dirty COW 漏洞模拟与分析

### 6.1 漏洞原理
Dirty COW (CVE-2016-5195) 是 Linux 内核中的一个竞态条件漏洞。在标准的 COW 过程中，内核需要完成三个步骤：
1.  分配新页。
2.  复制旧页内容到新页。
3.  更新页表，将虚拟地址指向新页并赋予写权限。

如果攻击者能在内核执行这些步骤的间隙（特别是复制完成但尚未更新页表时），通过另一个线程（如使用 `madvise` 告诉内核该页不再需要）干扰内存映射，可能导致内核错误地将写权限赋予了**原始的只读页**，而不是新复制的页。这会导致所有共享该只读页的进程（包括父进程或只读文件映射）的内存被修改。

### 6.2 模拟实现
由于 ucore Lab 5 是单核非抢占式环境，无法直接复现多线程竞态。我们通过修改内核代码，人为制造“跳过复制”的逻辑来模拟漏洞后果。

**攻击程序 (`user/dirtycow.c`)**:
```c
#include <ulib.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

volatile int global_data[1024]; // 共享页面

int main(void) {
    global_data[0] = 100;
    cprintf("Dirty COW Test: Initial value = %d\n", global_data[0]);
    int pid = fork();
    if (pid == 0) {
        // Child
        cprintf("Child: Attempting to write to global_data...\n");
        global_data[0] = 200; // 触发写时复制
        cprintf("Child: Wrote 200. Exiting.\n");
        exit(0);
    } else {
        // Parent
        wait();
        cprintf("Parent: global_data = %d\n", global_data[0]);
        if (global_data[0] == 200) {
            cprintf("VULNERABILITY REPRODUCED: Parent memory modified!\n");
        } else {
            cprintf("SAFE: Parent memory unchanged.\n");
        }
        exit(0);
    }
    return 0;
}
```

**内核漏洞植入 (`kern/mm/vmm.c`)**:
我们在 `do_pgfault` 中添加了恶意逻辑：如果检测到特定进程，直接修改原页面的权限为可写，而不进行内存复制。

```c
// 模拟代码片段
if (/* process is dirtycow */) {
    // 错误：直接将原物理页映射为可写，跳过 alloc_page 和 memcpy
    page_insert(mm->pgdir, pte2page(*ptep), la, (perm | PTE_W) & ~PTE_COW);
    return 0;
}
```

### 6.3 运行结果对比

**漏洞触发时**:
```text
Dirty COW Test: Initial value = 100
VULNERABILITY TRIGGERED: Skipping COW copy for process dirtycow
Child: Wrote 200. Exiting.
Parent: global_data = 200
VULNERABILITY REPRODUCED: Parent memory modified!
```
可以看到，子进程的修改污染了父进程的内存空间。

**修复后 (正常 COW)**:
```text
Dirty COW Test: Initial value = 100
Child: Wrote 200. Exiting.
Parent: global_data = 100
SAFE: Parent memory unchanged.
```
修复后的内核严格执行了“分配-复制-重映射”流程，保证了内存隔离。

## 7 用户程序加载机制说明

在本次实验中，用户程序（如 `dirtycow`）的加载方式与现代通用操作系统有所不同：

1.  **加载时机**:
    *   **ucore Lab 5**: 用户程序的二进制代码在**编译内核时**就被链接到了内核镜像（Kernel Image）的数据段中。系统启动时，这些程序已经存在于物理内存中。
    *   **通用 OS (Linux/Windows)**: 用户程序存储在磁盘文件系统中。只有当用户执行程序（如调用 `exec`）时，操作系统才将文件从磁盘加载到内存。

2.  **执行流程**:
    *   **ucore**: `kernel_execve` 通过宏（如 `_binary_obj___user_dirtycow_out_start`）直接获取内存中预存的 ELF 数据，调用 `load_icode` 解析并建立用户进程空间。
    *   **通用 OS**: `exec` 系统调用触发文件系统操作，读取磁盘块，可能利用 `mmap` 进行按需加载（Demand Paging）。

3.  **设计原因**:
    *   Lab 5 尚未实现文件系统和磁盘驱动。为了简化实验，专注于进程管理和虚拟内存（COW）的实现，采用“内嵌二进制”的方式规避了复杂的文件 I/O 操作。
